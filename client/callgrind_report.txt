--------------------------------------------------------------------------------
Profile data file 'callgrind.out.13108' (creator: callgrind-3.6.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 319488088
Trigger: Program termination
Profiled target:  ./pray_client ../scenes/testScene1.xml (PID 13108, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
           Ir 
--------------------------------------------------------------------------------
2,609,074,926  PROGRAM TOTALS

--------------------------------------------------------------------------------
         Ir  file:function
--------------------------------------------------------------------------------
902,181,951  src/triangle.cpp:Triangle::getIntersection(Ray&, float*, Vec3<float>*, Material**) [/home/guillaume/dev/pray/client/pray_client]
285,011,553  src/scene.cpp:_ZN5Scene19computeIntersectionER3RayPfP4Vec3IfEPP8Material.constprop.55 [/home/guillaume/dev/pray/client/pray_client]
259,337,142  src/sphere.cpp:Sphere::getIntersection(Ray&, float*, Vec3<float>*, Material**) [/home/guillaume/dev/pray/client/pray_client]
258,350,428  ./inc/vec3.h:Sphere::getIntersection(Ray&, float*, Vec3<float>*, Material**)
216,068,885  src/ray.cpp:Ray::getDirection() const [/home/guillaume/dev/pray/client/pray_client]
 73,835,970  src/ray.cpp:Ray::getOrigin() const [/home/guillaume/dev/pray/client/pray_client]
 60,758,962  src/phongMaterial.cpp:PhongMaterial::renderRay(Ray const&, float, Vec3<float> const&, Scene*) [/home/guillaume/dev/pray/client/pray_client]
 52,425,407  /usr/src/debug/SDL-1.2.14/src/video/SDL_blit_N.c:BlitNtoN [/usr/lib64/libSDL-1.2.so.0.11.3]
 50,688,000  ./inc/vec3.h:Camera::getDirection(int, int)
 50,331,363  src/scene.cpp:Scene::renderPixel(int, int) [/home/guillaume/dev/pray/client/pray_client]
 42,393,600  /home/guillaume/dev/pray/common/src/display.cpp:Display::add_pixel(int, int, Color) [/home/guillaume/dev/pray/client/pray_client]
 34,755,540  ./inc/vec3.h:Ray::Ray(Vec3<float> const&, Vec3<float> const&, Color&)
 23,683,758  src/ray.cpp:Ray::Ray(Vec3<float> const&, Vec3<float> const&, Color&) [/home/guillaume/dev/pray/client/pray_client]
 22,124,568  /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_MapRGB [/usr/lib64/libSDL-1.2.so.0.11.3]
 22,118,400  src/camera.cpp:Camera::getDirection(int, int) [/home/guillaume/dev/pray/client/pray_client]
 21,806,456  /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_pow.c:__pow_finite [/lib64/libm-2.14.90.so]
 17,968,930  src/scene.cpp:Scene::visibleLights(Vec3<float>) [/home/guillaume/dev/pray/client/pray_client]
 15,672,498  src/main.cpp:main [/home/guillaume/dev/pray/client/pray_client]
 13,275,284  /usr/src/debug/glibc-2.14-394-g8f3b1ff/libio/getc.c:getc [/lib64/libc-2.14.90.so]
 12,195,364  ./inc/vec3.h:PhongMaterial::renderRay(Ray const&, float, Vec3<float> const&, Scene*)
 11,479,984  /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_list.h:_ZN5Scene19computeIntersectionER3RayPfP4Vec3IfEPP8Material.constprop.55
  9,426,432  /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float, float, float) [/home/guillaume/dev/pray/client/pray_client]
  8,450,696  ???:0x0000003576a6f480 [/usr/lib64/libX11.so.6.3.0]
  7,698,180  src/scene.cpp:Scene::renderRay(Ray&) [/home/guillaume/dev/pray/client/pray_client]
  7,148,162  /usr/src/debug/glibc-2.14-394-g8f3b1ff/libio/libioP.h:getc
  6,854,722  ???:0x0000003576a6f4f0 [/usr/lib64/libX11.so.6.3.0]
  6,714,913  /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_exp.c:__exp1 [/lib64/libm-2.14.90.so]
  6,604,356  src/uglyMaterial.cpp:UglyMaterial::renderRay(Ray const&, float, Vec3<float> const&, Scene*) [/home/guillaume/dev/pray/client/pray_client]
  6,544,260  ???:_XimParseStringFile [/usr/lib64/libX11.so.6.3.0]
  6,298,620  /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_free [/lib64/libc-2.14.90.so]
  5,381,388  /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_malloc [/lib64/libc-2.14.90.so]
  4,908,548  ???:0x0000003576a56d20 [/usr/lib64/libX11.so.6.3.0]
  4,608,000  src/camera.cpp:Camera::getPoint() const [/home/guillaume/dev/pray/client/pray_client]
  4,559,836  /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() [/home/guillaume/dev/pray/client/pray_client]
  4,559,836  /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() [/home/guillaume/dev/pray/client/pray_client]
  4,559,836  /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() [/home/guillaume/dev/pray/client/pray_client]
  4,304,994  ./inc/vec3.h:_ZN5Scene19computeIntersectionER3RayPfP4Vec3IfEPP8Material.constprop.55
  4,234,537  /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc [/lib64/libc-2.14.90.so]
  3,686,400  ./inc/vec3.h:Scene::renderPixel(int, int)
  3,315,257  ???:XStringToKeysym [/usr/lib64/libX11.so.6.3.0]
  3,182,012  ???:_XrmInternalStringToQuark [/usr/lib64/libX11.so.6.3.0]
  3,102,046  ./inc/vec3.h:UglyMaterial::renderRay(Ray const&, float, Vec3<float> const&, Scene*)
  2,955,927  /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_pow.c:checkint [/lib64/libm-2.14.90.so]
  2,566,990  ./inc/vec3.h:Scene::visibleLights(Vec3<float>)
  2,552,957  /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-lookup.c:do_lookup_x [/lib64/ld-2.14.90.so]
  2,440,775  src/light.cpp:Light::getColor() [/home/guillaume/dev/pray/client/pray_client]
  2,312,715  /usr/src/debug/SDL-1.2.14/src/video/SDL_surface.c:SDL_FillRect [/usr/lib64/libSDL-1.2.so.0.11.3]
  2,055,015  src/directionalLight.cpp:DirectionalLight::getDirection() [/home/guillaume/dev/pray/client/pray_client]
  1,875,468  /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_list.h:Scene::visibleLights(Vec3<float>)
  1,543,601  /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/w_pow.c:pow [/lib64/libm-2.14.90.so]
  1,529,492  ???:XrmStringToQuark [/usr/lib64/libX11.so.6.3.0]
  1,374,520  /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:free [/lib64/libc-2.14.90.so]

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/libio/libioP.h
--------------------------------------------------------------------------------
       Ir 

-- line 960 ----------------------------------------
        .  # define CHECK_FILE(FILE, RET) COERCE_FILE (FILE)
        .  #endif
        .  
        .  static inline void
        .  __attribute__ ((__always_inline__))
        .  _IO_acquire_lock_fct (_IO_FILE **p)
        .  {
        .    _IO_FILE *fp = *p;
1,566,219    if ((fp->_flags & _IO_USER_LOCK) == 0)
5,802,389      _IO_funlockfile (fp);
        .  }
        .  
        .  static inline void
        .  __attribute__ ((__always_inline__))
        .  _IO_acquire_lock_clear_flags2_fct (_IO_FILE **p)
        .  {
        .    _IO_FILE *fp = *p;
        .    fp->_flags2 &= ~(_IO_FLAGS2_FORTIFY | _IO_FLAGS2_SCANF_STD);
-- line 977 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/light.cpp
--------------------------------------------------------------------------------
       Ir 

        .  #include "light.h"
        .  
        .  
        .  Light::Light(const Color &color) :
        8    color(color)
        .  {
        .  
        2  }
        .  
        .  Light::Light (float grey) :
        1    color(grey)
        4  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float) (1x)
        .  {
        .  
        .  }
        .  
        .  Light::Light (float r, float g, float b) :
        .    color(r, g, b)
        .  {
        .  
        .  }
        .  
        .  Color Light::getColor() {
1,464,465    return color;
  976,310  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/guillaume/dev/pray/common/src/display.cpp
--------------------------------------------------------------------------------
        Ir 

         .  #include "display.h"
         .  
         .  Display* Display::display_ptr;
         .  
         6  void Display::init(int height,int width) {
        13      static Display disp(height,width);
         7  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/guard.cc:__cxa_guard_release (1x)
        28  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/guard.cc:__cxa_guard_acquire (1x)
        65  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/stdlib/cxa_atexit.c:__cxa_atexit (1x)
         1      display_ptr=&disp;
         5  }
         .  
         .  Display& Display::getInstance() {
         .      return *display_ptr;
         2  }
         .  
       142  void Display::register_keyhook(std::function< void(void) > met,SDLKey key) {
         .      bindings.push_back(pair<std::function<void(void)>,SDLKey>(met,key));
       112  }
         .  
         .  void Display::refresh_display() {
         2      SDL_Flip(screen);
       653  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
    14,319  => /usr/src/debug/SDL-1.2.14/src/video/SDL_video.c:SDL_Flip (1x)
         .  }
         .  
         7  bool Display::refresh_controls() {
         .      SDL_Event event;
         1      bool change=false;
       512      while(SDL_PollEvent(&event)==1) {
   781,666  => /usr/src/debug/SDL-1.2.14/src/events/SDL_events.c:SDL_PollEvent (128x)
       741  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
       635          switch(event.type) {
         .          case SDL_KEYDOWN:
         .              for(unsigned int i=0;i<bindings.size();i++) {
         .                  if(bindings[i].second == event.key.keysym.sym) {
         .                      (bindings[i].first)();
         .                      change=true;
         .                  }
         .                  if(event.key.keysym.sym == SDLK_ESCAPE) {
         .                      quit_pressed=true;
         .                  }
         .              }
         .              break;
         .  
         .          case SDL_QUIT:
         1              quit_pressed=true;
         .              break;
         .  
         .          default:
         .              break;
         .          }
         .      }
         .  
         .      return change;
         7  }
         .  
         .  bool Display::quit() {
         2      return quit_pressed;
         2  }
         .  
         .  Display::Display(int p_width,int p_height) : 
         4      height(p_height),width(p_width), quit_pressed(false), screen(NULL)
         .  {
         4      if (SDL_Init(SDL_INIT_VIDEO) < 0)
       653  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
72,749,978  => /usr/src/debug/SDL-1.2.14/src/SDL.c:SDL_Init (1x)
         .      {
         .          Logger::log(LOG_ERROR)<<"Problem during SDL initialisation: "<<SDL_GetError()<<endl;
         .          exit(EXIT_FAILURE);
         .      }
         .  
         3      SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
        16  => /usr/src/debug/SDL-1.2.14/src/events/SDL_keyboard.c:SDL_EnableKeyRepeat (1x)
       837  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
         .  
         1      const SDL_VideoInfo* videoInfos = SDL_GetVideoInfo();
         5  => /usr/src/debug/SDL-1.2.14/src/video/SDL_video.c:SDL_GetVideoInfo (1x)
       789  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
         .  
         3      if (videoInfos->current_w < width) { // the screen is too small for the predifined resolution
         .          width = 0.9*videoInfos->current_w;
         .          height = 0.9*videoInfos->current_h; // to keep the screen ratio
         .      }
         .  
         3      SDL_WM_SetCaption(DEFAULT_NAME,NULL);
    31,767  => /usr/src/debug/SDL-1.2.14/src/video/SDL_video.c:SDL_WM_SetCaption (1x)
       805  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
         .  
         6      screen = SDL_SetVideoMode(width, height, 32, SDL_SWSURFACE | SDL_DOUBLEBUF);
       789  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 2,466,839  => /usr/src/debug/SDL-1.2.14/src/video/SDL_video.c:SDL_SetVideoMode (1x)
        13      Logger::log(LOG_INFO)<<"SDL initialised (video and controls) in "<<width<<"x"<<height<<endl;
     7,330  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/ostream.tcc:std::ostream::operator<<(int) (2x)
     1,365  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
     5,613  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::log(Log_Type) (1x)
         .  }
         .  
         4  Display::~Display() {
         7      SDL_SaveBMP(screen, "image.bmp");
     3,541  => /usr/src/debug/SDL-1.2.14/src/file/SDL_rwops.c:SDL_RWFromFile (1x)
53,399,790  => /usr/src/debug/SDL-1.2.14/src/video/SDL_bmp.c:SDL_SaveBMP_RW (1x)
     1,525  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (2x)
         3      Logger::log(LOG_INFO)<<"Rendered image saved"<<endl;
       453  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::log(Log_Type) (1x)
         .  
         1      SDL_Quit();
   181,919  => /usr/src/debug/SDL-1.2.14/src/SDL.c:SDL_Quit (1x)
       669  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
         3      Logger::log(LOG_INFO)<<"SDL Quit"<<endl;
       451  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::log(Log_Type) (1x)
         3  }
         .  
         .  int Display::get_width() {
         1      return width;
         1  }
         .  
         .  int Display::get_height() {
         1      return height;
         1  }
         .  
 5,529,600  void Display::add_pixel(int x,int y,Color color) {
         .      // all pixels are 32b-encoded
         .     
11,059,200      Uint32 *p = (Uint32 *)screen->pixels + x  + y * screen->pitch/4;
22,118,400      *p=SDL_MapRGB(screen->format,color.getR()*255,color.getG()*255,color.getB()*255);
22,118,400  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_MapRGB (921600x)
 1,843,200  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (921600x)
 1,843,200  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (921600x)
       685  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
 1,843,200  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (921600x)
 3,686,400  }
         .  
         .  void Display::add_surface(int x,int y,int width,int height,std::vector<Color> &pixels) {
         .      // all pixels are 32b-encoded
         .      int i=0;
         .      for(int h=0;h<height;h++) {
         .          for(int w=0;w<width;w++) {
         .              Uint32 *p = (Uint32 *)screen->pixels + (x+w) + (y+h) * (screen->pitch/4);
         .              *p=SDL_MapRGB(screen->format,pixels[i].getR()*255,pixels[i].getG()*255,pixels[i].getB()*255);
         .              i++;
         .          }        
         .      }
        22  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_pow.c
--------------------------------------------------------------------------------
       Ir 

-- line 50 ----------------------------------------
        .  double __slowpow(double x, double y,double z);
        .  static double power1(double x, double y);
        .  static int checkint(double x);
        .  
        .  /***************************************************************************/
        .  /* An ultimate power routine. Given two IEEE double machine numbers y,x    */
        .  /* it computes the correctly rounded (to nearest) value of X^y.            */
        .  /***************************************************************************/
  694,368  double __ieee754_pow(double x, double y) {
        .    double z,a,aa,error, t,a1,a2,y1,y2;
        .  #if 0
        .    double gor=1.0;
        .  #endif
        .    mynumber u,v;
        .    int k;
        .    int4 qx,qy;
  305,890    v.x=y;
  305,890    u.x=x;
  458,835    if (v.i[LOW_HALF] == 0) { /* of y */
  611,780      qx = u.i[HIGH_HALF]&0x7fffffff;
        .      /* Checking  if x is not too small to compute */
  458,835      if (((qx==0x7ff00000)&&(u.i[LOW_HALF]!=0))||(qx>0x7ff00000)) return NaNQ.x;
  535,987      if (y == 1.0) return x;
  535,987      if (y == 2.0) return x*x;
  535,987      if (y == -1.0) return 1.0/x;
  688,932      if (y == 0) return 1.0;
        .    }
        .    /* else */
  610,421    if(((u.i[HIGH_HALF]>0 && u.i[HIGH_HALF]<0x7ff00000)||        /* x>0 and not x->0 */
  231,456         (u.i[HIGH_HALF]==0 && u.i[LOW_HALF]!=0))  &&
        .  				      /*   2^-1023< x<= 2^-1023 * 0x1.0000ffffffff */
  308,608        (v.i[HIGH_HALF]&0x7fffffff) < 0x4ff00000) {              /* if y<-1 or y>1   */
        .      z = log1(x,&aa,&error);                                 /* x^y  =e^(y log (X)) */
  231,456      t = y*134217729.0;
  231,456      y1 = t - (t-y);
  154,304      y2 = y - y1;
  154,304      t = z*134217729.0;
  231,456      a1 = t - (t-z);
  154,304      a2 = (z - a1)+aa;
  154,304      a = y1*a1;
  231,456      aa = y2*a1 + y*a2;
  154,304      a1 = a+aa;
  154,304      a2 = (a-a1)+aa;
  462,912      error = error*ABS(y);
  925,824      t = __exp1(a1,a2,1.9e16*error);     /* return -10 or 0 if wasn't computed exactly */
6,710,363  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_exp.c:__exp1 (77152x)
1,002,899      return (t>0)?t:power1(x,y);
        .    }
        .  
  227,379    if (x == 0) {
        .      if (((v.i[HIGH_HALF] & 0x7fffffff) == 0x7ff00000 && v.i[LOW_HALF] != 0)
        .  	|| (v.i[HIGH_HALF] & 0x7fffffff) > 0x7ff00000)
        .        return y;
        .      if (ABS(y) > 1.0e20) return (y>0)?0:INF.x;
        .      k = checkint(y);
        .      if (k == -1)
        .        return y < 0 ? 1.0/x : x;
        .      else
        .        return y < 0 ? 1.0/ABS(x) : 0.0;                               /* return 0 */
        .    }
        .  
  151,586    qx = u.i[HIGH_HALF]&0x7fffffff;  /*   no sign   */
        .    qy = v.i[HIGH_HALF]&0x7fffffff;  /*   no sign   */
        .  
  151,586    if (qx >= 0x7ff00000 && (qx > 0x7ff00000 || u.i[LOW_HALF] != 0)) return NaNQ.x;
  151,586    if (qy >= 0x7ff00000 && (qy > 0x7ff00000 || v.i[LOW_HALF] != 0))
        .      return x == 1.0 ? 1.0 : NaNQ.x;
        .  
        .    /* if x<0 */
  151,586    if (u.i[HIGH_HALF] < 0) {
  757,930      k = checkint(y);
2,955,927  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_pow.c:checkint (75793x)
  757,930      if (k==0) {
        .        if (qy == 0x7ff00000) {
        .  	if (x == -1.0) return 1.0;
        .  	else if (x > -1.0) return v.i[HIGH_HALF] < 0 ? INF.x : 0.0;
        .  	else return v.i[HIGH_HALF] < 0 ? 0.0 : INF.x;
        .        }
        .        else if (qx == 0x7ff00000)
        .  	return y < 0 ? 0.0 : INF.x;
        .        return NaNQ.x;                              /* y not integer and x<0 */
        .      }
  151,586      else if (qx == 0x7ff00000)
        .        {
        .  	if (k < 0)
        .  	  return y < 0 ? nZERO.x : nINF.x;
        .  	else
        .  	  return y < 0 ? 0.0 : INF.x;
        .        }
  380,324      return (k==1)?__ieee754_pow(-x,y):-__ieee754_pow(-x,y); /* if y even or odd */
        .    }
        .    /* x>0 */
        .  
        .    if (qx == 0x7ff00000)                              /* x= 2^-0x3ff */
        .      {if (y == 0) return NaNQ.x;
        .      return (y>0)?x:0; }
        .  
        .    if (qy > 0x45f00000 && qy < 0x7ff00000) {
-- line 145 ----------------------------------------
-- line 147 ----------------------------------------
        .      if (y>0) return (x>1.0)?INF.x:0;
        .      if (y<0) return (x<1.0)?INF.x:0;
        .    }
        .  
        .    if (x == 1.0) return 1.0;
        .    if (y>0) return (x>1.0)?INF.x:0;
        .    if (y<0) return (x<1.0)?INF.x:0;
        .    return 0;     /* unreachable, to make the compiler happy */
  540,060  }
        .  strong_alias (__ieee754_pow, __pow_finite)
        .  
        .  /**************************************************************************/
        .  /* Computing x^y using more accurate but more slow log routine            */
        .  /**************************************************************************/
        .  static double power1(double x, double y) {
        .    double z,a,aa,error, t,a1,a2,y1,y2;
        .    z = my_log2(x,&aa,&error);
        .    t = y*134217729.0;
        .    y1 = t - (t-y);
        .    y2 = y - y1;
       77    t = z*134217729.0;
      231    a1 = t - (t-z);
      154    a2 = z - a1;
      154    a = y*z;
      847    aa = ((y1*a1-a)+y1*a2+y2*a1)+y2*a2+aa*y;
      154    a1 = a+aa;
      154    a2 = (a-a1)+aa;
      308    error = error*ABS(y);
      385    t = __exp1(a1,a2,1.9e16*error);
    4,550  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_exp.c:__exp1 (77x)
  303,565    return (t >= 0)?t:__slowpow(x,y,z);
  476,465  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/slowpow.c:__slowpow (2x)
        .  }
        .  
        .  /****************************************************************************/
        .  /* Computing log(x) (x is left argument). The result is the returned double */
        .  /* + the parameter delta.                                                   */
        .  /* The result is bounded by error (rightmost argument)                      */
        .  /****************************************************************************/
        .  static double log1(double x, double *delta, double *error) {
        .    int i,j,m;
        .  #if 0
        .    int n;
        .  #endif
   77,152    double uu,vv,eps,nx,e,e1,e2,t,t1,t2,res,add=0;
        .  #if 0
        .    double cor;
        .  #endif
        .    mynumber u,v;
        .  #ifdef BIG_ENDI
        .    mynumber
        .  /**/ two52          = {{0x43300000, 0x00000000}}; /* 2**52         */
        .  #else
        .  #ifdef LITTLE_ENDI
        .    mynumber
        .  /**/ two52          = {{0x00000000, 0x43300000}}; /* 2**52         */
        .  #endif
        .  #endif
        .  
  154,304    u.x = x;
  154,304    m = u.i[HIGH_HALF];
        .    *error = 0;
        .    *delta = 0;
  231,456    if (m < 0x00100000)             /*  1<x<2^-1007 */
        .      { x = x*t52.x; add = -52.0; u.x = x; m = u.i[HIGH_HALF];}
        .  
  308,608    if ((m&0x000fffff) < 0x0006a09e)
  133,065      {u.i[HIGH_HALF] = (m&0x000fffff)|0x3ff00000; two52.i[LOW_HALF]=(m>>20); }
        .    else
  561,303      {u.i[HIGH_HALF] = (m&0x000fffff)|0x3fe00000; two52.i[LOW_HALF]=(m>>20)+1; }
        .  
  540,064    v.x = u.x + bigu.x;
   77,152    uu = v.x - bigu.x;
  231,456    i = (v.i[LOW_HALF]&0x000003ff)<<2;
  154,304    if (two52.i[LOW_HALF] == 1023)         /* nx = 0              */
        .    {
  156,036        if (i > 1192 && i < 1208)          /* |x-1| < 1.5*2**-10  */
        .        {
       86  	  t = x - 1.0;
      344  	  t1 = (t+5.0e6)-5.0e6;
      172  	  t2 = t-t1;
      516  	  e1 = t - 0.5*t1*t1;
    1,634  	  e2 = t*t*t*(r3+t*(r4+t*(r5+t*(r6+t*(r7+t*r8)))))-0.5*t2*(t+t1);
      172  	  res = e1+e2;
      430  	  *error = 1.0e-21*ABS(t);
      258  	  *delta = (e1-res)+e2;
        .  	  return res;
        .        }                  /* |x-1| < 1.5*2**-10  */
        .        else
        .        {
  726,964  	  v.x = u.x*(ui.x[i]+ui.x[i+1])+bigv.x;
   51,926  	  vv = v.x-bigv.x;
   51,926  	  j = v.i[LOW_HALF]&0x0007ffff;
   51,926  	  j = j+j+j;
  155,778  	  eps = u.x - uu*vv;
  103,852  	  e1 = eps*ui.x[i];
  311,556  	  e2 = eps*(ui.x[i+1]+vj.x[j]*(ui.x[i]+ui.x[i+1]));
  103,852  	  e = e1+e2;
  103,852  	  e2 =  ((e1-e)+e2);
  311,556  	  t=ui.x[i+2]+vj.x[j+1];
  103,852  	  t1 = t+e;
1,090,446  	  t2 = (((t-t1)+e)+(ui.x[i+3]+vj.x[j+2]))+e2+e*e*(p2+e*(p3+e*p4));
  103,852  	  res=t1+t2;
   51,926  	  *error = 1.0e-24;
  155,778  	  *delta = (t1-res)+t2;
        .  	  return res;
        .        }
        .    }   /* nx = 0 */
        .    else                            /* nx != 0   */
        .    {
   25,140        eps = u.x - uu;
  100,560        nx = (two52.x - two52e.x)+add;
  100,560        e1 = eps*ui.x[i];
  100,560        e2 = eps*ui.x[i+1];
   50,280        e=e1+e2;
   50,280        e2 = (e1-e)+e2;
  125,700        t=nx*ln2a.x+ui.x[i+2];
   50,280        t1=t+e;
  553,080        t2=(((t-t1)+e)+nx*ln2b.x+ui.x[i+3]+e2)+e*e*(q2+e*(q3+e*(q4+e*(q5+e*q6))));
   50,280        res = t1+t2;
   25,140        *error = 1.0e-21;
   50,280        *delta = (t1-res)+t2;
        .        return res;
        .    }                                /* nx != 0   */
        .  }
        .  
        .  /****************************************************************************/
        .  /* More slow but more accurate routine of log                               */
        .  /* Computing log(x)(x is left argument).The result is return double + delta.*/
        .  /* The result is bounded by error (right argument)                           */
-- line 274 ----------------------------------------
-- line 290 ----------------------------------------
        .  /**/ two52          = {{0x43300000, 0x00000000}}; /* 2**52         */
        .  #else
        .  #ifdef LITTLE_ENDI
        .    mynumber
        .  /**/ two52          = {{0x00000000, 0x43300000}}; /* 2**52         */
        .  #endif
        .  #endif
        .  
      154    u.x = x;
      154    m = u.i[HIGH_HALF];
        .    *error = 0;
        .    *delta = 0;
       77    add=0;
      154    if (m<0x00100000) {  /* x < 2^-1022 */
        .      x = x*t52.x;  add = -52.0; u.x = x; m = u.i[HIGH_HALF]; }
        .  
      308    if ((m&0x000fffff) < 0x0006a09e)
      352      {u.i[HIGH_HALF] = (m&0x000fffff)|0x3ff00000; two52.i[LOW_HALF]=(m>>20); }
        .    else
      330      {u.i[HIGH_HALF] = (m&0x000fffff)|0x3fe00000; two52.i[LOW_HALF]=(m>>20)+1; }
        .  
      462    v.x = u.x + bigu.x;
       77    uu = v.x - bigu.x;
      154    i = (v.i[LOW_HALF]&0x000003ff)<<2;
        .    /*------------------------------------- |x-1| < 2**-11-------------------------------  */
      158    if ((two52.i[LOW_HALF] == 1023)  && (i == 1200))
        .    {
        .        t = x - 1.0;
        .        EMULV(t,s3,y,yy,j1,j2,j3,j4,j5);
        .        ADD2(-0.5,0,y,yy,z,zz,j1,j2);
        .        MUL2(t,0,z,zz,y,yy,j1,j2,j3,j4,j5,j6,j7,j8);
        .        MUL2(t,0,y,yy,z,zz,j1,j2,j3,j4,j5,j6,j7,j8);
        .  
        .        e1 = t+z;
-- line 323 ----------------------------------------
-- line 325 ----------------------------------------
        .        res = e1+e2;
        .        *error = 1.0e-25*ABS(t);
        .        *delta = (e1-res)+e2;
        .        return res;
        .    }
        .    /*----------------------------- |x-1| > 2**-11  --------------------------  */
        .    else
        .    {          /*Computing log(x) according to log table                        */
      308        nx = (two52.x - two52e.x)+add;
       77        ou1 = ui.x[i];
      154        ou2 = ui.x[i+1];
      231        lu1 = ui.x[i+2];
      231        lu2 = ui.x[i+3];
      616        v.x = u.x*(ou1+ou2)+bigv.x;
       77        vv = v.x-bigv.x;
       77        j = v.i[LOW_HALF]&0x0007ffff;
       77        j = j+j+j;
      231        eps = u.x - uu*vv;
      154        ov  = vj.x[j];
      154        lv1 = vj.x[j+1];
      154        lv2 = vj.x[j+2];
      308        a = (ou1+ou2)*(1.0+ov);
      308        a1 = (a+1.0e10)-1.0e10;
      308        a2 = a*(1.0-a1*uu*vv);
      154        e1 = eps*a1;
       77        e2 = eps*a2;
      154        e = e1+e2;
      154        e2 = (e1-e)+e2;
      308        t=nx*ln2a.x+lu1+lv1;
      154        t1 = t+e;
    1,232        t2 = (((t-t1)+e)+(lu2+lv2+nx*ln2b.x+e2))+e*e*(p2+e*(p3+e*p4));
      154        res=t1+t2;
      154        *error = 1.0e-27;
      231        *delta = (t1-res)+t2;
        .        return res;
        .    }
        .  }
        .  
        .  /**********************************************************************/
        .  /* Routine receives a double x and checks if it is an integer. If not */
        .  /* it returns 0, else it returns 1 if even or -1 if odd.              */
        .  /**********************************************************************/
        .  static int checkint(double x) {
        .    union {int4 i[2]; double x;} u;
        .    int k,m,n;
        .  #if 0
        .    int l;
        .  #endif
  151,586    u.x = x;
  303,172    m = u.i[HIGH_HALF]&0x7fffffff;    /* no sign */
  227,379    if (m >= 0x7ff00000) return 0;    /*  x is +/-inf or NaN  */
  227,379    if (m >= 0x43400000) return 1;    /*  |x| >= 2**53   */
  227,379    if (m < 0x40000000) return 0;     /* |x| < 2,  can not be 0 or 1  */
        .    n = u.i[LOW_HALF];
  227,379    k = (m>>20)-1023;                 /*  1 <= k <= 52   */
  151,586    if (k == 52) return (n&1)? -1:1;  /* odd or even*/
  151,586    if (k>20) {
        .      if (n<<(k-20)) return 0;        /* if not integer */
        .      return (n<<(k-21))?-1:1;
        .    }
  151,586    if (n) return 0;                  /*if  not integer*/
  151,586    if (k == 20) return (m&1)? -1:1;
  378,965    if (m<<(k+12)) return 0;
  530,551    return (m<<(k+11))?-1:1;
   75,793  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/bits/stl_list.h
--------------------------------------------------------------------------------
        Ir 

-- line 105 ----------------------------------------
         .      struct _List_node : public __detail::_List_node_base
         .      {
         .        ///< User's data.
         .        _Tp _M_data;
         .  
         .  #ifdef __GXX_EXPERIMENTAL_CXX0X__
         .        template<typename... _Args>
         .          _List_node(_Args&&... __args)
   617,320  	: __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...) 
         .          { }
         .  #endif
         .      };
         .  
         .    /**
         .     *  @brief A list::iterator.
         .     *
         .     *  All the functions are op overloads.
-- line 121 ----------------------------------------
-- line 146 ----------------------------------------
         .  
         .        pointer
         .        operator->() const
         .        { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }
         .  
         .        _Self&
         .        operator++()
         .        {
   333,851  	_M_node = _M_node->_M_next;
         .  	return *this;
         .        }
         .  
         .        _Self
         .        operator++(int)
         .        {
         .  	_Self __tmp = *this;
11,479,992  	_M_node = _M_node->_M_next;
         .  	return __tmp;
         .        }
         .  
         .        _Self&
         .        operator--()
         .        {
         .  	_M_node = _M_node->_M_prev;
         .  	return *this;
-- line 170 ----------------------------------------
-- line 226 ----------------------------------------
         .  
         .        pointer
         .        operator->() const
         .        { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }
         .  
         .        _Self&
         .        operator++()
         .        {
        25  	_M_node = _M_node->_M_next;
         .  	return *this;
         .        }
         .  
         .        _Self
         .        operator++(int)
         .        {
         .  	_Self __tmp = *this;
         .  	_M_node = _M_node->_M_next;
-- line 242 ----------------------------------------
-- line 372 ----------------------------------------
         .        { _M_clear(); }
         .  
         .        void
         .        _M_clear();
         .  
         .        void
         .        _M_init()
         .        {
   256,708          this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
   256,704          this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
         .        }
         .      };
         .  
         .    /**
         .     *  @brief A standard container with linear time access to elements,
         .     *  and fixed time insertion/deletion at any point in the sequence.
         .     *
         .     *  @ingroup sequences
-- line 389 ----------------------------------------
-- line 741 ----------------------------------------
         .  
         .        /**
         .         *  Returns a read/write iterator that points one past the last
         .         *  element in the %list.  Iteration is done in ordinary element
         .         *  order.
         .         */
         .        iterator
         .        end()
   256,699        { return iterator(&this->_M_impl._M_node); }
         .  
         .        /**
         .         *  Returns a read-only (constant) iterator that points one past
         .         *  the last element in the %list.  Iteration is done in ordinary
         .         *  element order.
         .         */
         .        const_iterator
         .        end() const
-- line 757 ----------------------------------------
-- line 1447 ----------------------------------------
         .          { _M_fill_initialize(static_cast<size_type>(__n), __x); }
         .  
         .        // Called by the range constructor to implement [23.1.1]/9
         .        template<typename _InputIterator>
         .          void
         .          _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
         .  			       __false_type)
         .          {
        43  	  for (; __first != __last; ++__first)
         .  	    push_back(*__first);
         .  	}
         .  
         .        // Called by list(n,v,a), and the range constructor when it turns out
         .        // to be the same thing.
         .        void
         .        _M_fill_initialize(size_type __n, const value_type& __x)
         .        {
-- line 1463 ----------------------------------------
-- line 1516 ----------------------------------------
         .          __tmp->_M_hook(__position._M_node);
         .        }
         .  #else
         .       template<typename... _Args>
         .         void
         .         _M_insert(iterator __position, _Args&&... __args)
         .         {
         .  	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
   231,543  	 __tmp->_M_hook(__position._M_node);
       119  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/src/../../../../libstdc++-v3/src/list.cc:std::__detail::_List_node_base::_M_hook(std::__detail::_List_node_base*) (17x)
     1,939  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
         .         }
         .  #endif
         .  
         .        // Erases element at position given.
         .        void
         .        _M_erase(iterator __position)
         .        {
         .          __position._M_node->_M_unhook();
-- line 1532 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_exp.c
--------------------------------------------------------------------------------
     Ir 

-- line 149 ----------------------------------------
      .  
      .  /************************************************************************/
      .  /* Compute e^(x+xx)(Double-Length number) .The routine also receive     */
      .  /* bound of error of previous calculation .If after computing exp       */
      .  /* error bigger than allows routine return non positive number          */
      .  /*else return   e^(x + xx)   (always positive )                         */
      .  /************************************************************************/
      .  
 77,229  double __exp1(double x, double xx, double error) {
      .    double bexp, t, eps, del, base, y, al, bet, res, rem, cor;
      .    mynumber junk1, junk2, binexp  = {{0,0}};
      .  #if 0
      .    int4 k;
      .  #endif
      .    int4 i,j,m,n,ex;
      .  
154,458    junk1.x = x;
154,458    m = junk1.i[HIGH_HALF];
154,458    n = m&hugeint;                 /* no sign */
      .  
231,687    if (n > smallint && n < bigint) {
308,600      y = x*log2e.x + three51.x;
231,450      bexp = y - three51.x;      /*  multiply the result by 2**bexp        */
      .  
154,300      junk1.x = y;
      .  
 77,150      eps = bexp*ln_two2.x;      /* x = bexp*ln(2) + t - eps               */
154,300      t = x - bexp*ln_two1.x;
      .  
231,450      y = t + three33.x;
 77,150      base = y - three33.x;      /* t rounded to a multiple of 2**-18      */
154,300      junk2.x = y;
231,450      del = (t - base) + (xx-eps);    /*  x = bexp*ln(2) + base + del      */
540,050      eps = del + del*del*(p3.x*del + p2.x);
      .  
231,450      binexp.i[HIGH_HALF] =(junk1.i[LOW_HALF]+1023)<<20;
      .  
308,600      i = ((junk2.i[LOW_HALF]>>8)&0xfffffffe)+356;
154,300      j = (junk2.i[LOW_HALF]&511)<<1;
      .  
617,200      al = coar.x[i]*fine.x[j];
848,650      bet =(coar.x[i]*fine.x[j+1] + coar.x[i+1]*fine.x[j]) + coar.x[i+1]*fine.x[j+1];
      .  
385,750      rem=(bet + bet*eps)+al*eps;
154,300      res = al + rem;
231,450      cor = (al - res) + rem;
848,466      if  (res == (res+cor*(1.0+error+err_1))) return res*binexp.x;
      .      else return -10.0;
      .    }
      .  
    237    if (n <= smallint) return 1.0; /*  if x->0 e^x=1 */
      .  
    158    if (n >= badint) {
    132      if (n > infint) return(zero/zero);    /* x is NaN,  return invalid */
    264      if (n < infint) return ( (x>0) ? (hhuge*hhuge) : (tiny*tiny) );
      .      /* x is finite,  cause either overflow or underflow  */
      .      if (junk1.i[LOW_HALF] != 0)  return (zero/zero);        /*  x is NaN  */
      .      return ((x>0)?inf.x:zero );   /* |x| = inf;  return either inf or 0 */
      .    }
      .  
     52    y = x*log2e.x + three51.x;
     39    bexp = y - three51.x;
     26    junk1.x = y;
     13    eps = bexp*ln_two2.x;
     26    t = x - bexp*ln_two1.x;
     39    y = t + three33.x;
     13    base = y - three33.x;
     26    junk2.x = y;
     39    del = (t - base) + (xx-eps);
     91    eps = del + del*del*(p3.x*del + p2.x);
     52    i = ((junk2.i[LOW_HALF]>>8)&0xfffffffe)+356;
     26    j = (junk2.i[LOW_HALF]&511)<<1;
    104    al = coar.x[i]*fine.x[j];
    143    bet =(coar.x[i]*fine.x[j+1] + coar.x[i+1]*fine.x[j]) + coar.x[i+1]*fine.x[j+1];
     65    rem=(bet + bet*eps)+al*eps;
     26    res = al + rem;
     39    cor = (al - res) + rem;
     26    if (m>>31) {
      .      ex=junk1.i[LOW_HALF];
     47      if (res < 1.0) {res+=res; cor+=cor; ex-=1;}
     26      if (ex >=-1022) {
      .        binexp.i[HIGH_HALF] = (1023+ex)<<20;
      .        if  (res == (res+cor*(1.0+error+err_1))) return res*binexp.x;
      .        else return -10.0;
      .      }
      .      ex = -(1022+ex);
     39      binexp.i[HIGH_HALF] = (1023-ex)<<20;
     39      res*=binexp.x;
     13      cor*=binexp.x;
     39      eps=1.00000000001+(error+err_1)*binexp.x;
     26      t=1.0+res;
     52      y = ((1.0-t)+res)+cor;
     26      res=t+y;
     39      cor = (t-res)+y;
     65      if (res == (res + eps*cor))
     52        {binexp.i[HIGH_HALF] = 0x00100000; return (res-1.0)*binexp.x;}
     92      else return -10.0;
      .    }
      .    else {
      .      binexp.i[HIGH_HALF] =(junk1.i[LOW_HALF]+767)<<20;
      .      if  (res == (res+cor*(1.0+error+err_1)))
      .        return res*binexp.x*t256.x;
      .      else return -10.0;
      .    }
     66  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/uglyMaterial.cpp
--------------------------------------------------------------------------------
       Ir 

        .  #include "uglyMaterial.h"
        .  #include "logger.h"
        .  #include <cmath>
        .  
        .  UglyMaterial::UglyMaterial(const Color &color) :
        5    color(color)
        .  {
        .  
        1  }
        .  
        .  Color UglyMaterial::getColor() {
        .    return color;
        .  }
        .  
        .  Color UglyMaterial::renderRay(const Ray & ray,
        .  			      float distance,
        .                                const Vec3<float> & normal,
  700,462                                Scene* /*nonUsedParameter*/) {
        .  
        .    //  Logger::log(LOG_DEBUG)<< "UGLYMATERIAL" <<endl;  
        .    //  Logger::log(LOG_DEBUG)<< distance <<endl;  
        .  
1,701,122    float factor = std::abs( ray.getDirection().scalar(normal) / (ray.getDirection().norm() * normal.norm()) );
1,000,660  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (200132x)
        .  
  500,330    float r = factor * color.getR();
  200,132  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (100066x)
  500,330    float g = factor * color.getG();
  200,132  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (100066x)
  400,264    float b = factor * color.getB();
  200,132  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (100066x)
        .  
  100,066    if(r>1) {
  800,528      r=1;
        .    }
        .    if(g>1) {
  500,330      g=1;
        .    }
        .    if(b>1) {
        .      b=1;
        .    }  
        .  
  700,462    return Color(r, g, b);
  400,264  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float, float, float) (100066x)
        .                 
  700,464  }
        .  

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/w_pow.c
--------------------------------------------------------------------------------
     Ir 

-- line 19 ----------------------------------------
      .  
      .  #include <math.h>
      .  #include <math_private.h>
      .  
      .  
      .  /* wrapper pow */
      .  double
      .  __pow (double x, double y)
231,456  {
231,456    double z = __ieee754_pow (x, y);
31,953,761  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/dbl-64/e_pow.c:__pow_finite (77152x)
617,216    if (__builtin_expect (!__finite (z), 0))
      .      {
      .        if (_LIB_VERSION != _IEEE_)
      .  	{
      .  	  if (__isnan (x))
      .  	    {
      .  	      if (y == 0.0)
      .  		/* pow(NaN,0.0) */
      .  		return __kernel_standard (x, y, 42);
-- line 37 ----------------------------------------
-- line 51 ----------------------------------------
      .  		    return __kernel_standard (x, y, 43);
      .  		}
      .  	      else
      .  		/* pow overflow */
      .  		return __kernel_standard (x, y, 21);
      .  	    }
      .  	}
      .      }
308,872    else if (__builtin_expect (z == 0.0, 0) && __finite (x) && __finite (y)
     99  	   && _LIB_VERSION != _IEEE_)
      .      {
     99        if (x == 0.0)
      .  	{
      .  	  if (y == 0.0)
      .  	    /* pow(0.0,0.0) */
      .  	    return __kernel_standard (x, y, 20);
      .  	}
      .        else
      .  	/* pow underflow */
    132  	return __kernel_standard (x, y, 22);
    957  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/../sysdeps/ieee754/k_standard.c:__kernel_standard (33x)
      .      }
      .  
      .    return z;
154,271  }
      .  weak_alias (__pow, pow)
      .  #ifdef NO_LONG_DOUBLE
      .  strong_alias (__pow, __powl)
      .  weak_alias (__pow, powl)
      .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-lookup.c
--------------------------------------------------------------------------------
     Ir 

-- line 69 ----------------------------------------
      .  #endif
      .  
      .  
      .  /* Inner part of the lookup functions.  We return a value > 0 if we
      .     found the symbol, the value 0 if nothing is found and < 0 if
      .     something bad happened.  */
      .  static int
      .  __attribute_noinline__
 50,686  do_lookup_x (const char *undef_name, uint_fast32_t new_hash,
      .  	     unsigned long int *old_hash, const ElfW(Sym) *ref,
      .  	     struct sym_val *result, struct r_scope_elem *scope, size_t i,
      .  	     const struct r_found_version *const version, int flags,
      .  	     struct link_map *skip, int type_class, struct link_map *undef_map)
 74,196  {
  6,183    size_t n = scope->r_nlist;
      .    /* Make sure we read the value before proceeding.  Otherwise we
      .       might use r_list pointing to the initial scope and r_nlist being
      .       the value after a resize.  That is the only path in dl-open.c not
      .       protected by GSCOPE.  A read barrier here might be to expensive.  */
      .    __asm volatile ("" : "+r" (n), "+m" (scope->r_list));
  6,183    struct link_map **list = scope->r_list;
      .  
      .    do
      .      {
      .        /* These variables are used in the nested function.  */
      .        Elf_Symndx symidx;
 41,577        int num_versions = 0;
 41,577        const ElfW(Sym) *versioned_sym = NULL;
      .  
124,731        const struct link_map *map = list[i]->l_real;
      .  
      .        /* Here come the extra test needed for `_dl_lookup_symbol_skip'.  */
 83,154        if (map == skip)
      .  	continue;
      .  
      .        /* Don't search the executable when resolving a copy reloc.  */
 83,376        if ((type_class & ELF_RTYPE_CLASS_COPY) && map->l_type == lt_executable)
      .  	continue;
      .  
      .        /* Do not look into objects which are going to be removed.  */
 83,122        if (map->l_removed)
      .  	continue;
      .  
      .        /* Print some debugging info if wanted.  */
 83,122        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_SYMBOLS, 0))
      .  	_dl_debug_printf ("symbol=%s;  lookup in file=%s [%lu]\n",
      .  			  undef_name,
      .  			  map->l_name[0] ? map->l_name : rtld_progname,
      .  			  map->l_ns);
      .  
      .        /* If the hash table is empty there is nothing to do here.  */
124,683        if (map->l_nbuckets == 0)
      .  	continue;
      .  
      .        /* The tables for this map.  */
124,683        const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);
124,683        const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
      .  
      .  
      .        /* Nested routine to check whether the symbol matches.  */
      .        const ElfW(Sym) *
      .        __attribute_noinline__
      .        check_match (const ElfW(Sym) *sym)
 29,561        {
  8,446  	unsigned int stt = ELFW(ST_TYPE) (sym->st_info);
      .  	assert (ELF_RTYPE_CLASS_PLT == 1);
 25,326  	if (__builtin_expect ((sym->st_value == 0 /* No value.  */
      .  			       && stt != STT_TLS)
 12,669  			      || (type_class & (sym->st_shndx == SHN_UNDEF)),
      .  			      0))
      .  	  return NULL;
      .  
      .  	/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,
      .  	   STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no
      .  	   code/data definitions.  */
      .  #define ALLOWED_STT \
      .  	((1 << STT_NOTYPE) | (1 << STT_OBJECT) | (1 << STT_FUNC) \
      .  	 | (1 << STT_COMMON) | (1 << STT_TLS) | (1 << STT_GNU_IFUNC))
 12,660  	if (__builtin_expect (((1 << stt) & ALLOWED_STT) == 0, 0))
      .  	  return NULL;
      .  
 15,634  	if (sym != ref && strcmp (strtab + sym->st_name, undef_name))
122,056  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/strcmp.S:strcmp (1199x)
      .  	  /* Not the symbol we are looking for.  */
      .  	  return NULL;
      .  
  8,440  	const ElfW(Half) *verstab = map->l_versyms;
 12,660  	if (version != NULL)
      .  	  {
  3,848  	    if (__builtin_expect (verstab == NULL, 0))
      .  	      {
      .  		/* We need a versioned symbol but haven't found any.  If
      .  		   this is the object which is referenced in the verneed
      .  		   entry it is a bug in the library since a symbol must
      .  		   not simply disappear.
      .  
      .  		   It would also be a bug in the object since it means that
      .  		   the list of required versions is incomplete and so the
-- line 165 ----------------------------------------
-- line 168 ----------------------------------------
      .  			|| ! _dl_name_match_p (version->filename, map));
      .  
      .  		/* Otherwise we accept the symbol.  */
      .  	      }
      .  	    else
      .  	      {
      .  		/* We can match the version information or use the
      .  		   default one if it is not hidden.  */
  3,848  		ElfW(Half) ndx = verstab[symidx] & 0x7fff;
 15,392  		if ((map->l_versions[ndx].hash != version->hash
  9,550  		     || strcmp (map->l_versions[ndx].name, version->name))
164,960  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/strcmp.S:strcmp (1910x)
     70  		    && (version->hidden || map->l_versions[ndx].hash
      .  			|| (verstab[symidx] & 0x8000)))
      .  		  /* It's not the version we want.  */
      .  		  return NULL;
      .  	      }
      .  	  }
      .  	else
      .  	  {
      .  	    /* No specific version is selected.  There are two ways we
-- line 187 ----------------------------------------
-- line 197 ----------------------------------------
      .  	       there is no problem at all: we simply use the symbol if it
      .  	       is defined.
      .  
      .  	       These two lookups need to be handled differently if the
      .  	       library defines versions.  In the case of the old
      .  	       unversioned application the oldest (default) version
      .  	       should be used.  In case of a dlsym() call the latest and
      .  	       public interface should be returned.  */
  4,592  	    if (verstab != NULL)
      .  	      {
 13,776  		if ((verstab[symidx] & 0x7fff)
  9,184  		    >= ((flags & DL_LOOKUP_RETURN_NEWEST) ? 2 : 3))
      .  		  {
      .  		    /* Don't accept hidden symbols.  */
      6  		    if ((verstab[symidx] & 0x8000) == 0
     15  			&& num_versions++ == 0)
      .  		      /* No version so far.  */
      3  		      versioned_sym = sym;
      .  
     40  		    return NULL;
      .  		  }
      .  	      }
      .  	  }
      .  
      .  	/* There cannot be another entry for this symbol so stop here.  */
      .  	return sym;
 29,561        }
      .  
      .        const ElfW(Sym) *sym;
 41,561        const ElfW(Addr) *bitmask = map->l_gnu_bitmask;
 83,122        if (__builtin_expect (bitmask != NULL, 1))
      .  	{
 41,561  	  ElfW(Addr) bitmask_word
 12,366  	    = bitmask[(new_hash / __ELF_NATIVE_CLASS)
 83,122  		      & map->l_gnu_bitmask_idxbits];
      .  
 12,366  	  unsigned int hashbit1 = new_hash & (__ELF_NATIVE_CLASS - 1);
166,244  	  unsigned int hashbit2 = ((new_hash >> map->l_gnu_shift)
      .  				   & (__ELF_NATIVE_CLASS - 1));
      .  
166,244  	  if (__builtin_expect ((bitmask_word >> hashbit1)
124,683  				& (bitmask_word >> hashbit2) & 1, 0))
      .  	    {
 11,776  	      Elf32_Word bucket = map->l_gnu_buckets[new_hash
 23,552  						     % map->l_nbuckets];
 11,776  	      if (bucket != 0)
      .  		{
 16,014  		  const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];
      .  
      .  		  do
 52,100  		    if (((*hasharr ^ new_hash) >> 1) == 0)
      .  		      {
 25,338  			symidx = hasharr - map->l_gnu_chain_zero;
 38,007  			sym = check_match (&symtab[symidx]);
502,297  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-lookup.c:check_match.10805 (4223x)
 25,378  			if (sym != NULL)
      .  			  goto found_it;
      .  		      }
 18,651  		  while ((*hasharr++ & 1u) == 0);
      .  		}
      .  	    }
      .  	  /* No symbol found.  */
 37,358  	  symidx = SHN_UNDEF;
      .  	}
      .        else
      .  	{
      .  	  if (*old_hash == 0xffffffff)
      .  	    *old_hash = _dl_elf_hash (undef_name);
      .  
      .  	  /* Use the old SysV-style hash table.  Search the appropriate
      .  	     hash bucket in this object's symbol table for a definition
-- line 266 ----------------------------------------
-- line 274 ----------------------------------------
      .  		goto found_it;
      .  	    }
      .  	}
      .  
      .        /* If we have seen exactly one versioned symbol while we are
      .  	 looking for an unversioned symbol and the version is not the
      .  	 default version we still accept this symbol since there are
      .  	 no possible ambiguities.  */
 74,719        sym = num_versions == 1 ? versioned_sym : NULL;
      .  
      6        if (sym != NULL)
      .  	{
      .  	found_it:
 28,946  	  switch (__builtin_expect (ELFW(ST_BIND) (sym->st_info), STB_GLOBAL))
      .  	    {
      .  	    case STB_WEAK:
      .  	      /* Weak definition.  Use this value if we don't find another.  */
  7,610  	      if (__builtin_expect (GLRO(dl_dynamic_weak), 0))
      .  		{
      .  		  if (! result->s)
      .  		    {
      .  		      result->s = sym;
      .  		      result->m = (struct link_map *) map;
      .  		    }
      .  		  break;
      .  		}
      .  	      /* FALLTHROUGH */
      .  	    case STB_GLOBAL:
      .  	    success:
      .  	      /* Global definition.  Just what we need.  */
  4,206  	      result->s = sym;
  8,412  	      result->m = (struct link_map *) map;
  8,461  	      return 1;
      .  
      .  	    case STB_GNU_UNIQUE:;
      .  	      /* We have to determine whether we already found a
      .  		 symbol with this name before.  If not then we have to
      .  		 add it to the search table.  If we already found a
      .  		 definition we have to use it.  */
      .  	      void enter (struct unique_sym *table, size_t size,
      .  			  unsigned int hash, const char *name,
      .  			  const ElfW(Sym) *sym, const struct link_map *map)
      .  	      {
    644  		size_t idx = hash % size;
    476  		size_t hash2 = 1 + hash % (size - 2);
    394  		while (table[idx].name != NULL)
      .  		  {
    156  		    idx += hash2;
    156  		    if (idx >= size)
     86  		      idx -= size;
      .  		  }
      .  
    119  		table[idx].hashval = hash;
    119  		table[idx].name = name;
    168  		table[idx].sym = sym;
    119  		table[idx].map = map;
      .  	      }
      .  
    245  	      struct unique_sym_table *tab
     49  		= &GL(dl_ns)[map->l_ns]._ns_unique_sym_table;
      .  
     98  	      __rtld_lock_lock_recursive (tab->lock);
     98  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/rtld.c:rtld_lock_default_lock_recursive (49x)
      .  
     98  	      struct unique_sym *entries = tab->entries;
     49  	      size_t size = tab->size;
     98  	      if (entries != NULL)
      .  		{
    192  		  size_t idx = new_hash % size;
    370  		  size_t hash2 = 1 + new_hash % (size - 2);
      .  		  while (1)
      .  		    {
    603  		      if (entries[idx].hashval == new_hash
    119  			  && strcmp (entries[idx].name, undef_name) == 0)
      .  			{
      .  			  if ((type_class & ELF_RTYPE_CLASS_COPY) != 0)
      .  			    {
      .  			      /* We possibly have to initialize the central
      .  				 copy from the copy addressed through the
      .  				 relocation.  */
      .  			      result->s = sym;
      .  			      result->m = (struct link_map *) map;
-- line 354 ----------------------------------------
-- line 357 ----------------------------------------
      .  			    {
      .  			      result->s = entries[idx].sym;
      .  			      result->m = (struct link_map *) entries[idx].map;
      .  			    }
      .  			  __rtld_lock_unlock_recursive (tab->lock);
      .  			  return 1;
      .  			}
      .  
    380  		      if (entries[idx].name == NULL)
      .  			break;
      .  
      .  		      idx += hash2;
    179  		      if (idx >= size)
    246  			idx -= size;
      .  		    }
      .  
    288  		  if (size * 3 <= tab->n_elements * 4)
      .  		    {
      .  		      /* Expand the table.  */
      .  #ifdef RTLD_CHECK_FOREIGN_CALL
      .  		      /* This must not happen during runtime relocations.  */
      6  		      assert (!RTLD_CHECK_FOREIGN_CALL);
      .  #endif
      8  		      size_t newsize = _dl_higher_prime_number (size + 1);
    144  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-misc.c:_dl_higher_prime_number (2x)
      8  		      struct unique_sym *newentries
     99  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-minimal.c:calloc (2x)
      .  			= calloc (sizeof (struct unique_sym), newsize);
      4  		      if (newentries == NULL)
      .  			{
      .  			nomem:
      .  			  __rtld_lock_unlock_recursive (tab->lock);
      6  			  _dl_fatal_printf ("out of memory\n");
      .  			}
      .  
    386  		      for (idx = 0; idx < size; ++idx)
    276  			if (entries[idx].name != NULL)
    210  			  enter (newentries, newsize, entries[idx].hashval,
      .  				 entries[idx].name, entries[idx].sym,
      .  				 entries[idx].map);
      .  
      4  		      tab->free (entries);
     12  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-minimal.c:free (2x)
      2  		      tab->size = newsize;
      .  		      size = newsize;
      4  		      entries = tab->entries = newentries;
      8  		      tab->free = free;
      .  		    }
      .  		}
      .  	      else
      .  		{
      .  #ifdef RTLD_CHECK_FOREIGN_CALL
      .  		  /* This must not happen during runtime relocations.  */
      3  		  assert (!RTLD_CHECK_FOREIGN_CALL);
      .  #endif
      .  
      .  #ifdef SHARED
      .  		  /* If tab->entries is NULL, but tab->size is not, it means
      .  		     this is the second, conflict finding, lookup for
      .  		     LD_TRACE_PRELINKING in _dl_debug_bindings.  Don't
      .  		     allocate anything and don't enter anything into the
      .  		     hash table.  */
      2  		  if (__builtin_expect (tab->size, 0))
      .  		    {
      .  		      assert (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK);
      .  		      __rtld_lock_unlock_recursive (tab->lock);
      .  		      goto success;
      .  		    }
      .  #endif
      .  
      .  #define INITIAL_NUNIQUE_SYM_TABLE 31
      1  		  size = INITIAL_NUNIQUE_SYM_TABLE;
      4  		  entries = calloc (sizeof (struct unique_sym), size);
     38  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-minimal.c:calloc (1x)
      2  		  if (entries == NULL)
      .  		    goto nomem;
      .  
      1  		  tab->entries = entries;
      1  		  tab->size = size;
      4  		  tab->free = free;
      .  		}
      .  
     98  	      if ((type_class & ELF_RTYPE_CLASS_COPY) != 0)
    147  		enter (entries, size, new_hash, strtab + sym->st_name, ref,
      .  		       undef_map);
      .  	      else
      .  		{
     49  		  enter (entries, size, new_hash, strtab + sym->st_name, sym,
      .  			 map);
      .  
    196  		  if (map->l_type == lt_loaded)
      .  		    /* Make sure we don't unload this object by
      .  		       setting the appropriate flag.  */
      .  		    ((struct link_map *) map)->l_flags_1 |= DF_1_NODELETE;
      .  		}
     49  	      ++tab->n_elements;
      .  
    147  	      __rtld_lock_unlock_recursive (tab->lock);
     98  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/rtld.c:rtld_lock_default_unlock_recursive (49x)
      .  
     49  	      goto success;
      .  
      .  	    default:
      .  	      /* Local symbols are ignored.  */
      .  	      break;
      .  	    }
      .  	}
      .  
      .        /* If this current map is the one mentioned in the verneed entry
      .  	 and we have not found a weak entry, it is a bug.  */
150,411        if (symidx == STN_UNDEF && version != NULL && version->filename != NULL
 56,331  	  && __builtin_expect (_dl_name_match_p (version->filename, map), 0))
294,890  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-misc.c:_dl_name_match_p (5121x)
      .  	return -1;
      .      }
112,113    while (++i < n);
      .  
      .    /* We have not found anything until now.  */
  1,977    return 0;
 49,464  }
      .  
      .  
      .  static uint_fast32_t
      .  dl_new_hash (const char *s)
      .  {
      .    uint_fast32_t h = 5381;
435,780    for (unsigned char c = *s; c != '\0'; c = *++s)
506,470      h = h * 33 + c;
      .    return h & 0xffffffff;
      .  }
      .  
      .  
      .  /* Add extra dependency on MAP to UNDEF_MAP.  */
      .  static int
      .  internal_function
      .  add_dependency (struct link_map *undef_map, struct link_map *map, int flags)
      .  {
      .    struct link_map *runp;
      .    unsigned int i;
      .    int result = 0;
      .  
      .    /* Avoid self-references and references to objects which cannot be
      .       unloaded anyway.  */
  6,726    if (undef_map == map)
      .      return 0;
      .  
      .    /* Avoid references to objects which cannot be unloaded anyway.  */
      .    assert (map->l_type == lt_loaded);
    406    if ((map->l_flags_1 & DF_1_NODELETE) != 0)
      .      return 0;
      .  
      .    struct link_map_reldeps *l_reldeps
    203      = atomic_forced_read (undef_map->l_reldeps);
      .  
      .    /* Make sure l_reldeps is read before l_initfini.  */
      .    atomic_read_barrier ();
      .  
      .    /* Determine whether UNDEF_MAP already has a reference to MAP.  First
      .       look in the normal dependencies.  */
    406    struct link_map **l_initfini = atomic_forced_read (undef_map->l_initfini);
    406    if (l_initfini != NULL)
      .      {
  2,199        for (i = 0; l_initfini[i] != NULL; ++i)
  1,139  	if (l_initfini[i] == map)
      .  	  return 0;
      .      }
      .  
      .    /* No normal dependency.  See whether we already had to add it
      .       to the special list of dynamic dependencies.  */
      .    unsigned int l_reldepsact = 0;
      .    if (l_reldeps != NULL)
      .      {
-- line 522 ----------------------------------------
-- line 703 ----------------------------------------
      .  /* Search loaded objects' symbol tables for a definition of the symbol
      .     UNDEF_NAME, perhaps with a requested version for the symbol.
      .  
      .     We must never have calls to the audit functions inside this function
      .     or in any function which gets called.  If this would happen the audit
      .     code might create a thread which can throw off all the scope locking.  */
      .  lookup_t
      .  internal_function
    840  _dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,
  8,560  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/rtld-strlen.S:strlen (360x)
      .  		     const ElfW(Sym) **ref,
      .  		     struct r_scope_elem *symbol_scope[],
      .  		     const struct r_found_version *version,
      .  		     int type_class, int flags, struct link_map *skip_map)
 61,208  {
      .    const uint_fast32_t new_hash = dl_new_hash (undef_name);
  8,744    unsigned long int old_hash = 0xffffffff;
  8,744    struct sym_val current_value = { NULL, NULL };
      .    struct r_scope_elem **scope = symbol_scope;
      .  
  4,372    bump_num_relocations ();
      .  
      .    /* No other flag than DL_LOOKUP_ADD_DEPENDENCY or DL_LOOKUP_GSCOPE_LOCK
      .       is allowed if we look up a versioned symbol.  */
 12,564    assert (version == NULL
      .  	  || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK))
      .  	     == 0);
      .  
  4,372    size_t i = 0;
  8,744    if (__builtin_expect (skip_map != NULL, 0))
      .      /* Search the relevant loaded objects for a definition.  */
  8,744      while ((*scope)->r_list[i] != skip_map)
      .        ++i;
      .  
      .    /* Search the relevant loaded objects for a definition.  */
 35,951    for (size_t start = i; *scope != NULL; start = 0, ++scope)
      .      {
 92,745        int res = do_lookup_x (undef_name, new_hash, &old_hash, *ref,
3,350,633  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-lookup.c:do_lookup_x (6183x)
      .  			     &current_value, *scope, start, version, flags,
      .  			     skip_map, type_class, undef_map);
 12,366        if (res > 0)
      .  	break;
      .  
  3,954        if (__builtin_expect (res, 0) < 0 && skip_map == NULL)
      .  	{
      .  	  /* Oh, oh.  The file named in the relocation entry does not
      .  	     contain the needed symbol.  This code is never reached
      .  	     for unversioned lookups.  */
      .  	  assert (version != NULL);
      .  	  const char *reference_name = undef_map ? undef_map->l_name : NULL;
      .  
      .  	  /* XXX We cannot translate the message.  */
-- line 753 ----------------------------------------
-- line 762 ----------------------------------------
      .  					  " with link time reference",
      .  					  res == -2
      .  					  ? " (no version symbols)" : ""));
      .  	  *ref = NULL;
      .  	  return 0;
      .  	}
      .      }
      .  
  8,744    if (__builtin_expect (current_value.s == NULL, 0))
      .      {
    682        if ((*ref == NULL || ELFW(ST_BIND) ((*ref)->st_info) != STB_WEAK)
    240  	  && skip_map == NULL)
      .  	{
      .  	  /* We could find no value for a strong reference.  */
    480  	  const char *reference_name = undef_map ? undef_map->l_name : "";
    360  	  const char *versionstr = version ? ", version " : "";
      .  	  const char *versionname = (version && version->name
    120  				     ? version->name : "");
      .  
      .  	  /* XXX We cannot translate the message.  */
    840  	  _dl_signal_cerror (0, (reference_name[0]
 47,583  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/elf/dl-error.c:_dl_signal_cerror (120x)
      .  				 ? reference_name
      .  				 : (rtld_progname ?: "<main program>")),
      .  			     N_("symbol lookup error"),
  2,880  			     make_string (undefined_msg, undef_name,
 14,762  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/strcpy.S:stpcpy (360x)
  1,440  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/strcpy.S:strcpy (120x)
      .  					  versionstr, versionname));
      .  	}
     46        *ref = NULL;
     92        return 0;
      .      }
      .  
 12,618    int protected = (*ref
 24,168  		   && ELFW(ST_VISIBILITY) ((*ref)->st_other) == STV_PROTECTED);
      .    if (__builtin_expect (protected != 0, 0))
      .      {
      .        /* It is very tricky.  We need to figure out what value to
      .  	 return for the protected symbol.  */
      .        if (type_class == ELF_RTYPE_CLASS_PLT)
      .  	{
      .  	  if (current_value.s != NULL && current_value.m != undef_map)
      .  	    {
-- line 802 ----------------------------------------
-- line 821 ----------------------------------------
      .  	    }
      .  	}
      .      }
      .  
      .    /* We have to check whether this would bind UNDEF_MAP to an object
      .       in the global scope which was dynamically loaded.  In this case
      .       we have to prevent the latter from being unloaded unless the
      .       UNDEF_MAP object is also unloaded.  */
 16,824    if (__builtin_expect (current_value.m->l_type == lt_loaded, 0)
      .        /* Don't do this for explicit lookups as opposed to implicit
      .  	 runtime lookups.  */
  4,100        && (flags & DL_LOOKUP_ADD_DEPENDENCY) != 0
      .        /* Add UNDEF_MAP to the dependencies.  */
    406        && add_dependency (undef_map, current_value.m, flags) < 0)
      .        /* Something went wrong.  Perhaps the object we tried to reference
      .  	 was just removed.  Try finding another definition.  */
      .        return _dl_lookup_symbol_x (undef_name, undef_map, ref,
      .  				  (flags & DL_LOOKUP_GSCOPE_LOCK)
      .  				  ? undef_map->l_scope : symbol_scope,
      .  				  version, type_class, flags, skip_map);
      .  
      .    /* The object is used.  */
 12,618    if (__builtin_expect (current_value.m->l_used == 0, 0))
      2      current_value.m->l_used = 1;
      .  
 16,824    if (__builtin_expect (GLRO(dl_debug_mask)
      .  			& (DL_DEBUG_BINDINGS|DL_DEBUG_PRELINK), 0))
      .      _dl_debug_bindings (undef_name, undef_map, ref,
      .  			&current_value, version, type_class, protected);
      .  
  4,206    *ref = current_value.s;
      .    return LOOKUP_VALUE (current_value.m);
 38,268  }
      .  
      .  
      .  /* Cache the location of MAP's hash table.  */
      .  
      .  void
      .  internal_function
      .  _dl_setup_hash (struct link_map *map)
     26  {
      .    Elf_Symndx *hash;
      .    Elf_Symndx nchain;
      .  
     78    if (__builtin_expect (map->l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
      .  				    + DT_THISPROCNUM + DT_VERSIONTAGNUM
      .  				    + DT_EXTRANUM + DT_VALNUM] != NULL, 1))
      .      {
     26        Elf32_Word *hash32
      .  	= (void *) D_PTR (map, l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
      .  				      + DT_THISPROCNUM + DT_VERSIONTAGNUM
      .  				      + DT_EXTRANUM + DT_VALNUM]);
     52        map->l_nbuckets = *hash32++;
     26        Elf32_Word symbias = *hash32++;
     26        Elf32_Word bitmask_nwords = *hash32++;
      .        /* Must be a power of two.  */
     78        assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
     26        map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
     78        map->l_gnu_shift = *hash32++;
      .  
     26        map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
     52        hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;
      .  
     26        map->l_gnu_buckets = hash32;
     26        hash32 += map->l_nbuckets;
    104        map->l_gnu_chain_zero = hash32 - symbias;
      .        return;
      .      }
      .  
      .    if (!map->l_info[DT_HASH])
      .      return;
      .    hash = (void *) D_PTR (map, l_info[DT_HASH]);
      .  
      .    map->l_nbuckets = *hash++;
      .    nchain = *hash++;
      .    map->l_buckets = hash;
      .    hash += map->l_nbuckets;
      .    map->l_chain = hash;
     52  }
      .  
      .  
      .  static void
      .  internal_function
      .  _dl_debug_bindings (const char *undef_name, struct link_map *undef_map,
      .  		    const ElfW(Sym) **ref, struct sym_val *value,
      .  		    const struct r_found_version *version, int type_class,
      .  		    int protected)
-- line 907 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/directionalLight.cpp
--------------------------------------------------------------------------------
       Ir 

        .  #include "directionalLight.h"
        .  
        5  DirectionalLight::DirectionalLight(const Color &color, const Vec3<float> &direction) :
        5    Light(color), direction(direction)
        5  => /home/guillaume/dev/pray/client/src/light.cpp:Light::Light(Color const&) (1x)
        .  {
        .  
        4  }
        .  
        .  DirectionalLight::DirectionalLight(float color, const Vec3<float> &direction) :
        .    Light(color), direction(direction)
        .  {
        .  
        .  }
        .  
        .  DirectionalLight::DirectionalLight(float r, float g, float b, const Vec3<float> &direction) :
        .    Light(r, g, b), direction(direction)
        .  {
        .  
        .  }
        .  
        .  Vec3<float> DirectionalLight::getDirection() {
1,233,009    return direction;
  822,006  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/scene.cpp
--------------------------------------------------------------------------------
        Ir 

         .  #include "logger.h"
         .  #include "scene.h"
         .  #include "material.h"
         .  #include "uglyMaterial.h"
         .  
        12  Scene::Scene(const list<Object*> objects,
         .  	     const list<DirectionalLight> &directionalLights,
         .  	     const AmbientLight &ambientLight,
         .  	     Camera* camera) :
         .    objects(objects),
         .    directionalLights(directionalLights),
         .    ambientLight(ambientLight),
         6    camera(camera)
         .  {
         .  
         8  }
         .  
         6  Scene::~Scene()
         .  {
         .      list<Object*>::iterator iter;
         .  
        19      for (iter = objects.begin() ; iter != objects.end() ; iter++) {
        40          delete *iter;
       736  => /home/guillaume/dev/pray/client/./inc/triangle.h:Triangle::~Triangle() (4x)
       736  => /home/guillaume/dev/pray/client/./inc/sphere.h:Sphere::~Sphere() (4x)
         .      }
         .  
         .      //delete camera;
         6  }
         .  
         .  list<Object*> Scene::getObjects() {
         .    return objects;
         .  }
         .  
         .  list<DirectionalLight> Scene::getDirectionalLights() {
         .    return directionalLights;
         .  }
         .  
         .  AmbientLight Scene::getAmbientLight() {
   770,097    return ambientLight;
   513,398  }
         .  
         .  Camera* Scene::getCamera() {
        14    return camera;
        14  }
         .  
 1,283,495  Color Scene::renderRay(Ray &ray) {
         .    float distance;
         .    Vec3<float> normal;
 1,178,299    Material* material = 0;
         .  
 7,734,695    computeIntersection(ray, &distance, &normal, &material);
1,302,095,788  => src/scene.cpp:_ZN5Scene19computeIntersectionER3RayPfP4Vec3IfEPP8Material.constprop.55 (921600x)
         .  
 4,713,196    if (distance < 0) { // no intersection was found
         .      //    Logger::log(LOG_DEBUG) << "NO INTERSECTION" << endl;
 8,780,303      return Color(1,1,1);
 2,259,852  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float, float, float) (564963x)
         .    } else {
         .      //    Logger::log(LOG_DEBUG) << "INTERSECTION : " << material << endl;
 4,489,250      return material->renderRay(ray, distance, normal, this);
906,562,259  => /home/guillaume/dev/pray/client/src/phongMaterial.cpp:PhongMaterial::renderRay(Ray const&, float, Vec3<float> const&, Scene*) (256606x)
12,103,751  => /home/guillaume/dev/pray/client/src/uglyMaterial.cpp:UglyMaterial::renderRay(Ray const&, float, Vec3<float> const&, Scene*) (100031x)
         .    }
 1,283,495  }
         .  
         .  /**
         .   * *distance < 0 if no intersection was found
         .   */
17,219,976  void Scene::computeIntersection(Ray &ray, float *distance, Vec3<float> *normal,
         .                                  Material **material) {
         .  
 1,434,998      *distance = -2;
 1,434,998      float tempDistance = -1;
         .      Vec3<float> tempNormal;
         .      Material* tempMaterial;
         .      list<Object*>::iterator iter;
         .  
28,703,274      for (iter = objects.begin(); iter != objects.end(); iter++)
         .      {
91,839,872          (*iter)->getIntersection(ray, &tempDistance, &tempNormal, &tempMaterial);
1,126,381,236  => /home/guillaume/dev/pray/client/src/triangle.cpp:Triangle::getIntersection(Ray&, float*, Vec3<float>*, Material**) (5739992x)
576,872,740  => /home/guillaume/dev/pray/client/src/sphere.cpp:Sphere::getIntersection(Ray&, float*, Vec3<float>*, Material**) (5739992x)
         .  
         .  	// Fixes the precision problem for shadows.
89,556,940  	if(tempDistance < 0 && tempDistance > -0.1) {
    48,805  	  tempDistance = -tempDistance;
         .        	}
         .  	// ----------------------------------------
         .  
         .  
26,064,338          if (tempDistance >= 0
         .              && ((*distance >= 0 && tempDistance < *distance)
         .                  || *distance < 0 ))
         .          {
   616,198              *distance = tempDistance;
 2,464,792              *normal = tempNormal;
 1,232,396              *material = tempMaterial;
         .          }
         .  
11,479,984          tempDistance = -1;
         .      }
         .      
11,479,984  }
         .  
         .  
 2,764,800  Color Scene::renderPixel(int x, int y) {
         .  
 6,451,200      Vec3<float> direction  = camera->getDirection(x, y); //.normalize();
72,806,400  => /home/guillaume/dev/pray/client/src/camera.cpp:Camera::getDirection(int, int) (921600x)
 4,608,000      Color color = Color(0,0,0);
 3,686,400  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float, float, float) (921600x)
 6,451,200      Vec3<float> origin = camera->getPoint();
 4,608,000  => /home/guillaume/dev/pray/client/src/camera.cpp:Camera::getPoint() const (921600x)
 4,608,000      Ray r = Ray(origin, direction, color);
32,256,000  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::Ray(Vec3<float> const&, Vec3<float> const&, Color&) (921600x)
         .      //    Logger::log(LOG_DEBUG) << "before scene::renderRay" << endl;
         .      return renderRay(r);
 3,686,400  }
         .  
         .  /**
         .   * Give the lights that are visible from a point. Used for shadows.
         .   */
 2,310,291  list<DirectionalLight> Scene::visibleLights(Vec3<float> point) {
         .  
   256,699    float distance = -1;
         .    Vec3<float> normal;
         .    Material *material;
   770,097    Color color = Color(0.0);
 1,026,796  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float) (256699x)
         .    list<DirectionalLight> result = list<DirectionalLight>();
 1,283,495    Ray ray = Ray(point, normal, color);
 8,214,368  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::Ray(Vec3<float> const&, Vec3<float> const&, Color&) (256699x)
         .  
 2,566,990    for(DirectionalLight l : directionalLights) {
 6,417,475      ray = Ray(point, l.getDirection()*(-1), color);
 1,283,495  => /home/guillaume/dev/pray/client/src/directionalLight.cpp:DirectionalLight::getDirection() (256699x)
 8,984,465  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::Ray(Vec3<float> const&, Vec3<float> const&, Color&) (256699x)
 1,540,194      computeIntersection(ray, &distance, &normal, &material);
353,620,305  => src/scene.cpp:_ZN5Scene19computeIntersectionER3RayPfP4Vec3IfEPP8Material.constprop.55 (256699x)
         .      //  Logger::log(LOG_DEBUG)<< distance <<endl;      
   770,097        if(distance < 0) {
         .  	result.push_back(l);
         .        }
         .    }
         .  
         .    return result;
 3,488,595  }

--------------------------------------------------------------------------------
-- Auto-annotated source: ./inc/vec3.h
--------------------------------------------------------------------------------
         Ir 

-- line 21 ----------------------------------------
          .      Vec3<number> operator*(Vec3<number> n);
          .      Vec3<number> operator*(number n);
          .      Vec3<number> operator/(number n);
          .      Vec3<number> rotate(float angle, Vec3<number> axis);
          .      Vec3<number> symmetry(Vec3<number> x);
          .  };
          .  
          .  template <class number>
 10,558,384  Vec3<number>::Vec3(number x,number y,number z) : x(x), y(y), z(z) {
          .  }
          .  
          .  template <class number>
          .  number Vec3<number>::norm() const {
132,912,331      return sqrt(x*x+y*y+z*z);
          .  }
          .  
          .  template <class number>
          .  Vec3<number> Vec3<number>::normalize() const{
          .      number val=norm();
          .      Vec3<number> result = Vec3<number>();
 34,484,332      if(val!=0) {
  9,888,648          result.x = x/val;
  9,888,648          result.y = y/val;
 17,471,840          result.z = z/val;
          .      }
          .      return result;
          .  }
          .  
          .  template <class number>
          .  Vec3<number> Vec3<number>::operator+(Vec3<number> n) {
  3,404,549      n.x+=x;
  3,404,549      n.y+=y;
  4,431,345      n.z+=z;
          .      return n;
          .  }
          .  
          .  template <class number>
          .  void Vec3<number>::operator+=(Vec3<number> n) {
          .      x+=n.x;
          .      y+=n.y;
          .      z+=n.z;
          .  }
          .  
          .  template <class number>
          .  Vec3<number> Vec3<number>::operator-(Vec3<number> n) {
          .      Vec3<number> res;
 11,837,052      res.x=x-n.x;
 11,837,052      res.y=y-n.y;
 11,837,052      res.z=z-n.z;
          .      return res;
          .  }
          .  
          .  template <class number>
          .  void Vec3<number>::operator-=(Vec3<number> n) {
          .      x-=n.x;
          .      y-=n.y;
          .      z-=n.z;
-- line 77 ----------------------------------------
-- line 81 ----------------------------------------
          .  template <class number>
          .  Vec3<number> Vec3<number>::operator*(Vec3<number> n) {
          .      return cross(n);
          .  }
          .  
          .  template <class number>
          .  Vec3<number> Vec3<number>::operator*(number n) {
          .      Vec3<number> res;
  7,427,601      res.x=x*n;
  7,581,905      res.y=y*n;
  4,713,953      res.z=z*n;
          .      return res;
          .  }
          .  
          .  template <class number>
          .  Vec3<number> Vec3<number>::operator/(number n) {
          .      Vec3<number> res;
          .      res.x=x/n;
          .      res.y=y/n;
-- line 99 ----------------------------------------
-- line 100 ----------------------------------------
          .      res.z=z/n;
          .      return res;
          .  }
          .  
          .  //cross product (vector product)
          .  template <class number>
          .  Vec3<number> Vec3<number>::cross(Vec3<number> n) {
          .      Vec3<number> res;
  6,451,225      res.x=y*n.z-z*n.y;
  5,529,617      res.y=z*n.x-x*n.z;
  2,764,817      res.z=x*n.y-y*n.x;
          .      return res;
          .  }
          .  
          .  //scalar product (dot product)
          .  template <class number>
          .  number Vec3<number>::scalar(Vec3<number> n) const {
 73,922,305      return n.x*x+n.y*y+n.z*z;
          .  }
          .  
          .  // phi : angle in degrees
          .  template <class number>
          .  Vec3<number> Vec3<number>::rotate(float phi, Vec3<number> axis) {
          .      phi = phi * 3.14159265  / 180; // angle in radians
          .      return (*this) * (float)(cos(phi)) + (float)(1-cos(phi)) * this->scalar(axis) + axis.cross(*this) * (float)(sin(phi));
          .  }
          .  
          .  template <class number>
          .  Vec3<number> Vec3<number>::symmetry(Vec3<number> x) {
    333,851      return x*(2*(*this).scalar(x)) + (*this)*(-1);
          .  }
          .  
          .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/guillaume/dev/pray/common/src/color.cpp
--------------------------------------------------------------------------------
       Ir 

        .  #include "color.h"
        .  
        .  Color::Color(float grey) :
  770,103    r(grey), g(grey), b(grey)
        .  {
        .    
  256,701  }
        .  
        .  Color::Color(float r, float g, float b) :
7,069,824    r(r), g(g), b(b)
        .  {
        .    
2,356,608  }
        .  
        .  float Color::getR() {
2,279,918    return r;
2,279,918  }
        .  
        .  float Color::getG() {
2,279,918    return g;
2,279,918  }
        .  
        .  float Color::getB() {
2,279,918    return b;
2,279,918  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/sphere.cpp
--------------------------------------------------------------------------------
        Ir 

         .  #include "logger.h"
         .  #include "sphere.h"
         .  #include <math.h>
         .  
        20  Sphere::Sphere(const Vec3<float> &center,
         .                 float radius,
         .                 Material* material) :
         .      Object(material),
         .      center(center),
        40      radius(radius)
        12  => /home/guillaume/dev/pray/client/src/object.cpp:Object::Object(Material*) (4x)
         .  {
         .  
        16  }
         .  
         .  Vec3<float> Sphere::getCenter() const {
         .      return center;
         .  }
         .  
         .  float Sphere::getRadius() const {
         .      return radius;
         .  }
         .  
         .  /**
         .   * *distance < 0 if no intersection was found
         .   */
         .  void Sphere::getIntersection(Ray& ray,
         .                               float* distance,
         .                               Vec3<float>* normal,
63,139,912                               Material** materialIntersection) {
         .  
         .      // http://www.cs.princeton.edu/courses/archive/fall00/
         .      //                                 cs426/lectures/raycast/sld013.htm
         .  
40,179,944      Vec3<float> L = center - ray.getOrigin();
28,699,960  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getOrigin() const (5739992x)
57,399,920      Vec3<float> V = ray.getDirection().normalize();
28,699,960  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (5739992x)
         .      float t_ca = L.scalar(V);
11,479,984      if (t_ca < 0) {
         .          *distance = -1;
         .      } else {
13,839,084          float d2 = L.scalar(L) - t_ca * t_ca;
 9,226,056          float r2 = radius * radius;
 9,226,056          if (d2 > r2) {
 5,382,942              *distance = -1;
         .          } else {
 1,428,200              float t_hc = sqrt(r2 - d2);
   714,100              float t1 = t_ca - t_hc;
   357,050              float t2 = t_ca + t_hc;
   714,100              *distance = (t1<t2) ? t1 : t2;
 3,927,550              Vec3<float> OP = ray.getOrigin() + V*(*distance) - center;
 1,785,250  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getOrigin() const (357050x)
 1,071,150              *normal = OP.normalize();
 1,071,150              *materialIntersection = material;
         .          }
         .      }
40,179,946  }
         .  

--------------------------------------------------------------------------------
-- Auto-annotated source: src/camera.cpp
--------------------------------------------------------------------------------
        Ir 

         .  #include "logger.h"
         .  #include "camera.h"
         .  
        10  Camera::Camera(Vec3<float> point,
         .                 Vec3<float> direction,
         .                 Vec3<float> normal,
         .                 float viewplaneWidth,
         .                 float viewplaneHeight,
         .                 float viewplaneDist,
         .                 int xResolution,
         .                 int yResolution,
         .  	       int transFactor,
-- line 12 ----------------------------------------
-- line 17 ----------------------------------------
         .      normal(normal.normalize()),
         .      viewplaneWidth(viewplaneWidth),
         .      viewplaneHeight(viewplaneHeight),
         .      viewplaneDist(viewplaneDist),
         .      xResolution(xResolution),
         .      yResolution(yResolution),
         .      transFactor(transFactor),
         .      rotatAngle(rotatAngle),
        17      mode(mode)
         .  {
         3      lateral = direction.cross(normal);
         .      
         5      if (! (direction.scalar(normal) < 1e-6)) {
         .          Logger::log(LOG_WARNING)<<"Incorrect camera : direction and normal are not orthogonal"<<std::endl;
         .      }
         4  }
         .  
         .  Vec3<float> Camera::getPoint() const {
 2,764,800      return point;
 1,843,200  }
         .  
         .  Vec3<float> Camera::getDirection() const {
         .      return direction;
         .  }
         .  
         .  Vec3<float> Camera::getNormal() const {
         .      return normal;
         .  }
-- line 44 ----------------------------------------
-- line 62 ----------------------------------------
         .  float Camera::getViewplaneHeight() const {
         .      return viewplaneHeight;
         .  }
         .  
         .  float Camera::getViewplaneDist() const {
         .      return viewplaneDist;
         .  }
         .  
   921,600  Vec3<float> Camera::getDirection(int x, int y) {
   921,600      return (direction*viewplaneDist
 6,451,200              + normal*(viewplaneHeight/2 - y*(viewplaneHeight/yResolution))
11,059,200              + direction*normal*(viewplaneWidth/2 - x*(viewplaneWidth/xResolution))).normalize();
 2,764,800  }
         .  
         .  Vec3<float> Camera::horizontalProj(Vec3<float> vec) {
         .      vec.z = 0;
         .      return vec.normalize();
         .  }
         .  
         .  void Camera::translateForward() {
         .      switch (mode) {
-- line 82 ----------------------------------------
-- line 227 ----------------------------------------
         .          break;
         .      }
         .  }
         .  
         .  void Camera::logInformations() {
         .      Logger::log(LOG_INFO)<<"Camera : position = ("<<point.x<<", "<<point.y<<", "<<point.z<<")"<<std::endl;
         .      Logger::log(LOG_INFO)<<"       : direction = ("<<direction.x<<", "<<direction.y<<", "<<direction.z<<")"<<std::endl;
         .      Logger::log(LOG_INFO)<<"       : normal = ("<<normal.x<<", "<<normal.y<<", "<<normal.z<<")"<<std::endl;
         2  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/triangle.cpp
--------------------------------------------------------------------------------
         Ir 

          .  #include "triangle.h"
          .  #include "logger.h"
          .  
          .  
          .  
         36  Triangle::Triangle(Vec3<float> &a, Vec3<float> &b, Vec3<float> &c, Material *material) :
         72      Object(material), a(a), b(b), c(c), normal(((b - a) * (b - c)).normalize())
         12  => /home/guillaume/dev/pray/client/src/object.cpp:Object::Object(Material*) (4x)
          .  {
          .  
         24  }
          .  
          .  Vec3<float> Triangle::getA() {
          .      return a;
          .  }
          .  
          .  Vec3<float> Triangle::getB() {
          .      return b;
          .  }
-- line 18 ----------------------------------------
-- line 35 ----------------------------------------
          .      dest.z = v1.x * v2.y - v1.y * v2.x;
          .  #define DOT(v1,v2) (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z)
          .  #define SUB(dest,v1,v2)                         \
          .      dest.x = v1.x - v2.x;                       \
          .      dest.y = v1.y - v2.y;                       \
          .      dest.z = v1.z - v2.z;
          .  
          .  void Triangle::getIntersection(Ray &ray, float *distance, Vec3<float> *normal,
 63,139,912                                 Material **material) {
          .      
          .      // ray : R(t) = orig + t * dir
          .  
          .      // point(u,v) = (1 - u - v) * A + u * B + v * C
          .      // (u,v) barycentric coordinates
          .      
          .      Vec3<float> edge1, edge2, tvec, pvec, qvec;
          .      float det, u, v; /* inv_det, t */
          .      
          .      // find vectors for two edges sharing A
 51,659,928      SUB(edge1, b, a);
 45,919,936      SUB(edge2, c, a);
          .      
          .      // begin calculating determiant - also used to calculate U parameter
407,539,432      CROSS(pvec, ray.getDirection(), edge2);
172,199,760  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (34439952x)
          .  
          .      // if determinant is near zero, ray lies in plane of triangle
 63,139,912      det = DOT(edge1, pvec);
          .  
 28,699,960      if (det < EPSILON) {
          .          *distance = -1;
          .          return;
          .      }
          .  
          .      // calculate distance from A to ray origin
 95,162,130      SUB(tvec, ray.getOrigin(), a);
 40,783,770  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getOrigin() const (8156754x)
          .  
          .      // calculate U parameter and test bounds
 27,189,180      u = DOT(tvec, pvec);
 24,530,482      if (u < 0.0 || u > det) {
          .          *distance = -1;
          .          return;
          .      }
          .  
          .      // prepare to test V parameter
  8,224,887      CROSS(qvec, tvec, edge1);
          .  
          .      // calculate V parameter and test bounds
 29,160,963      v = DOT(ray.getDirection(), qvec);
 11,215,755  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (2243151x)
  7,834,275      if (v < 0.0 || u + v > det) {
  5,427,606          *distance = -1;
          .          return;
          .      }
          .  
          .      // calculate t, scale parameters, ray intersects triangle
          .      /*t = DOT(edge2, qvec);
          .      inv_det = 1.0 / det;
          .      t *= inv_det;
          .      u *= inv_det;
          .      v *= inv_det;*/
  2,186,702      *distance = DOT(edge2, qvec) / det;
          .  
          .      /* *distance = t;*/
  1,249,544      *normal = this->normal;
    937,158      *material = this->material;
 40,179,946  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c
--------------------------------------------------------------------------------
       Ir 

-- line 31 ----------------------------------------
        .  #include "SDL_RLEaccel_c.h"
        .  
        .  /* Helper functions */
        .  /*
        .   * Allocate a pixel format structure and fill it according to the given info.
        .   */
        .  SDL_PixelFormat *SDL_AllocFormat(int bpp,
        .  			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
       36  {
        .  	SDL_PixelFormat *format;
        .  	Uint32 mask;
        .  
        .  	/* Allocate an empty pixel format structure */
        9  	format = SDL_malloc(sizeof(*format));
      528  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc (3x)
        6  	if ( format == NULL ) {
        .  		SDL_OutOfMemory();
        .  		return(NULL);
        .  	}
        .  	SDL_memset(format, 0, sizeof(*format));
        3  	format->alpha = SDL_ALPHA_OPAQUE;
        .  
        .  	/* Set up the format */
        3  	format->BitsPerPixel = bpp;
       18  	format->BytesPerPixel = (bpp+7)/8;
       15  	if ( Rmask || Bmask || Gmask ) { /* Packed pixels with custom mask */
        3  		format->palette = NULL;
        3  		format->Rshift = 0;
        3  		format->Rloss = 8;
        6  		if ( Rmask ) {
      252  			for ( mask = Rmask; !(mask&0x01); mask >>= 1 )
        .  				++format->Rshift;
      129  			for ( ; (mask&0x01); mask >>= 1 )
        .  				--format->Rloss;
        .  		}
        3  		format->Gshift = 0;
        3  		format->Gloss = 8;
        6  		if ( Gmask ) {
      132  			for ( mask = Gmask; !(mask&0x01); mask >>= 1 )
        .  				++format->Gshift;
      129  			for ( ; (mask&0x01); mask >>= 1 )
        .  				--format->Gloss;
        .  		}
        3  		format->Bshift = 0;
        3  		format->Bloss = 8;
        6  		if ( Bmask ) {
       15  			for ( mask = Bmask; !(mask&0x01); mask >>= 1 )
        .  				++format->Bshift;
      129  			for ( ; (mask&0x01); mask >>= 1 )
        .  				--format->Bloss;
        .  		}
        3  		format->Ashift = 0;
        3  		format->Aloss = 8;
        6  		if ( Amask ) {
        .  			for ( mask = Amask; !(mask&0x01); mask >>= 1 )
        .  				++format->Ashift;
        .  			for ( ; (mask&0x01); mask >>= 1 )
        .  				--format->Aloss;
        .  		}
        3  		format->Rmask = Rmask;
        3  		format->Gmask = Gmask;
        3  		format->Bmask = Bmask;
        3  		format->Amask = Amask;
        .  	} else if ( bpp > 8 ) {		/* Packed pixels with standard mask */
        .  		/* R-G-B */
        .  		if ( bpp > 24 )
        .  			bpp = 24;
        .  		format->Rloss = 8-(bpp/3);
        .  		format->Gloss = 8-(bpp/3)-(bpp%3);
        .  		format->Bloss = 8-(bpp/3);
        .  		format->Rshift = ((bpp/3)+(bpp%3))+(bpp/3);
-- line 100 ----------------------------------------
-- line 113 ----------------------------------------
        .  		format->Gshift = 0;
        .  		format->Bshift = 0;
        .  		format->Ashift = 0;
        .  		format->Rmask = 0;
        .  		format->Gmask = 0;
        .  		format->Bmask = 0;
        .  		format->Amask = 0;
        .  	}
        6  	if ( bpp <= 8 ) {			/* Palettized mode */
        .  		int ncolors = 1<<bpp;
        .  #ifdef DEBUG_PALETTE
        .  		fprintf(stderr,"bpp=%d ncolors=%d\n",bpp,ncolors);
        .  #endif
        .  		format->palette = (SDL_Palette *)SDL_malloc(sizeof(SDL_Palette));
        .  		if ( format->palette == NULL ) {
        .  			SDL_FreeFormat(format);
        .  			SDL_OutOfMemory();
-- line 129 ----------------------------------------
-- line 215 ----------------------------------------
        .  			format->palette->colors[1].b = 0x00;
        .  		} else {
        .  			/* Create an empty palette */
        .  			SDL_memset((format->palette)->colors, 0,
        .  				(format->palette)->ncolors*sizeof(SDL_Color));
        .  		}
        .  	}
        .  	return(format);
       27  }
        .  SDL_PixelFormat *SDL_ReallocFormat(SDL_Surface *surface, int bpp,
        .  			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
       13  {
        3  	if ( surface->format ) {
        1  		SDL_FreeFormat(surface->format);
       89  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_FreeFormat (1x)
        2  		SDL_FormatChanged(surface);
       19  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_FormatChanged (1x)
        .  	}
        7  	surface->format = SDL_AllocFormat(bpp, Rmask, Gmask, Bmask, Amask);
      435  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_AllocFormat (1x)
        .  	return surface->format;
        8  }
        .  
        .  /*
        .   * Change any previous mappings from/to the new surface format
        .   */
        .  void SDL_FormatChanged(SDL_Surface *surface)
        .  {
        .  	static int format_version = 0;
        9  	++format_version;
        6  	if ( format_version < 0 ) { /* It wrapped... */
        .  		format_version = 1;
        .  	}
        3  	surface->format_version = format_version;
        6  	SDL_InvalidateMap(surface->map);
       23  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_InvalidateMap (3x)
        .  }
        .  /*
        .   * Free a previously allocated format structure
        .   */
        .  void SDL_FreeFormat(SDL_PixelFormat *format)
        6  {
        6  	if ( format ) {
        9  		if ( format->palette ) {
        .  			if ( format->palette->colors ) {
        .  				SDL_free(format->palette->colors);
        .  			}
        .  			SDL_free(format->palette);
        .  		}
        6  		SDL_free(format);
      242  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:free (3x)
        .  	}
        3  }
        .  /*
        .   * Calculate an 8-bit (3 red, 3 green, 2 blue) dithered palette of colors
        .   */
        .  void SDL_DitherColors(SDL_Color *colors, int bpp)
        .  {
        .  	int i;
        .  	if(bpp != 8)
        .  		return;		/* only 8bpp supported right now */
-- line 270 ----------------------------------------
-- line 288 ----------------------------------------
        .  /* 
        .   * Calculate the pad-aligned scanline width of a surface
        .   */
        .  Uint16 SDL_CalculatePitch(SDL_Surface *surface)
        .  {
        .  	Uint16 pitch;
        .  
        .  	/* Surface should be 4-byte aligned for speed */
        9  	pitch = surface->w*surface->format->BytesPerPixel;
       15  	switch (surface->format->BitsPerPixel) {
        .  		case 1:
        .  			pitch = (pitch+7)/8;
        .  			break;
        .  		case 4:
        .  			pitch = (pitch+1)/2;
        .  			break;
        .  		default:
        .  			break;
        .  	}
        6  	pitch = (pitch + 3) & ~3;	/* 4-byte aligning */
        .  	return(pitch);
        3  }
        .  /*
        .   * Match an RGB value to a particular palette index
        .   */
        .  Uint8 SDL_FindColor(SDL_Palette *pal, Uint8 r, Uint8 g, Uint8 b)
        .  {
        .  	/* Do colorspace distance matching */
        .  	unsigned int smallest;
        .  	unsigned int distance;
-- line 317 ----------------------------------------
-- line 335 ----------------------------------------
        .  	}
        .  	return(pixel);
        .  }
        .  
        .  /* Find the opaque pixel value corresponding to an RGB triple */
        .  Uint32 SDL_MapRGB
        .  (const SDL_PixelFormat * const format,
        .   const Uint8 r, const Uint8 g, const Uint8 b)
1,843,714  {
2,765,571  	if ( format->palette == NULL ) {
6,452,999  		return (r >> format->Rloss) << format->Rshift
5,531,142  		       | (g >> format->Gloss) << format->Gshift
5,531,142  		       | (b >> format->Bloss) << format->Bshift
        .  		       | format->Amask;
        .  	} else {
        .  		return SDL_FindColor(format->palette, r, g, b);
        .  	}
        .  }
        .  
        .  /* Find the pixel value corresponding to an RGBA quadruple */
        .  Uint32 SDL_MapRGBA
-- line 355 ----------------------------------------
-- line 499 ----------------------------------------
        .  
        .  	dithered.ncolors = 256;
        .  	SDL_DitherColors(colors, 8);
        .  	dithered.colors = colors;
        .  	return(Map1to1(&dithered, pal, identical));
        .  }
        .  
        .  SDL_BlitMap *SDL_AllocBlitMap(void)
        2  {
        .  	SDL_BlitMap *map;
        .  
        .  	/* Allocate the empty map */
        6  	map = (SDL_BlitMap *)SDL_malloc(sizeof(*map));
      348  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc (2x)
        4  	if ( map == NULL ) {
        .  		SDL_OutOfMemory();
        .  		return(NULL);
        .  	}
        .  	SDL_memset(map, 0, sizeof(*map));
        .  
        .  	/* Allocate the software blit data */
        6  	map->sw_data = (struct private_swaccel *)SDL_malloc(sizeof(*map->sw_data));
      207  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc (2x)
        4  	if ( map->sw_data == NULL ) {
        .  		SDL_FreeBlitMap(map);
        .  		SDL_OutOfMemory();
        .  		return(NULL);
        .  	}
        .  	SDL_memset(map->sw_data, 0, sizeof(*map->sw_data));
        .  
        .  	/* It's ready to go */
        .  	return(map);
        6  }
        .  void SDL_InvalidateMap(SDL_BlitMap *map)
       12  {
       12  	if ( ! map ) {
        .  		return;
        .  	}
        4  	map->dst = NULL;
        4  	map->format_version = (unsigned int)-1;
       12  	if ( map->table ) {
        .  		SDL_free(map->table);
        .  		map->table = NULL;
        .  	}
       12  }
        .  int SDL_MapSurface (SDL_Surface *src, SDL_Surface *dst)
        9  {
        .  	SDL_PixelFormat *srcfmt;
        .  	SDL_PixelFormat *dstfmt;
        .  	SDL_BlitMap *map;
        .  
        .  	/* Clear out any previous mapping */
        1  	map = src->map;
        3  	if ( (src->flags & SDL_RLEACCEL) == SDL_RLEACCEL ) {
        .  		SDL_UnRLESurface(src, 1);
        .  	}
        2  	SDL_InvalidateMap(map);
       11  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_InvalidateMap (1x)
        .  
        .  	/* Figure out what kind of mapping we're doing */
        1  	map->identity = 0;
        1  	srcfmt = src->format;
        1  	dstfmt = dst->format;
        2  	switch (srcfmt->BytesPerPixel) {
        .  	    case 1:
        .  		switch (dstfmt->BytesPerPixel) {
        .  		    case 1:
        .  			/* Palette --> Palette */
        .  			/* If both SDL_HWSURFACE, assume have same palette */
        .  			if ( ((src->flags & SDL_HWSURFACE) == SDL_HWSURFACE) &&
        .  			     ((dst->flags & SDL_HWSURFACE) == SDL_HWSURFACE) ) {
        .  				map->identity = 1;
-- line 567 ----------------------------------------
-- line 583 ----------------------------------------
        .  			map->table = Map1toN(srcfmt, dstfmt);
        .  			if ( map->table == NULL ) {
        .  				return(-1);
        .  			}
        .  			break;
        .  		}
        .  		break;
        .  	default:
        2  		switch (dstfmt->BytesPerPixel) {
        .  		    case 1:
        .  			/* BitField --> Palette */
        .  			map->table = MapNto1(srcfmt, dstfmt, &map->identity);
        .  			if ( ! map->identity ) {
        .  				if ( map->table == NULL ) {
        .  					return(-1);
        .  				}
        .  			}
        .  			map->identity = 0;	/* Don't optimize to copy */
        .  			break;
        .  		    default:
        .  			/* BitField --> BitField */
        3  			if ( FORMAT_EQUAL(srcfmt, dstfmt) )
        .  				map->identity = 1;
        .  			break;
        .  		}
        .  		break;
        .  	}
        .  
        1  	map->dst = dst;
        2  	map->format_version = dst->format_version;
        .  
        .  	/* Choose your blitters wisely */
        2  	return(SDL_CalculateBlit(src));
      160  => /usr/src/debug/SDL-1.2.14/src/video/SDL_blit.c:SDL_CalculateBlit (1x)
        7  }
        .  void SDL_FreeBlitMap(SDL_BlitMap *map)
        4  {
        4  	if ( map ) {
        2  		SDL_InvalidateMap(map);
       22  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_InvalidateMap (2x)
        6  		if ( map->sw_data != NULL ) {
        2  			SDL_free(map->sw_data);
      163  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:free (2x)
        .  		}
        4  		SDL_free(map);
      163  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:free (2x)
        .  	}
        2  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/phongMaterial.cpp
--------------------------------------------------------------------------------
       Ir 

-- line 10 ----------------------------------------
        .  			     float diffuseReflection, 
        .  			     float ambiantReflection, 
        .  			     float shininess) :
        .    color(color), 
        .    specularReflection(specularReflection), 
        .    diffuseReflection(diffuseReflection),
        .    ambiantReflection(ambiantReflection), 
        .    shininess(shininess),
       70    reflectivity(1)
        .  {
        .  
        7  }
        .  
        .  PhongMaterial::PhongMaterial(const Color &color, 
        .  			     float specularReflection, 
        .  			     float diffuseReflection, 
        .  			     float ambiantReflection, 
        .  			     float shininess,
        .  			     float reflectivity) :
        .    color(color), 
-- line 29 ----------------------------------------
-- line 55 ----------------------------------------
        .  float PhongMaterial::getShininess() {
        .    return shininess;
        .  }
        .  
        .  float PhongMaterial::getReflectivity() {
        .    return reflectivity;
        .  }
        .  
2,823,689  Color PhongMaterial::renderRay(const Ray &ray, float distance, const Vec3<float> &normal, Scene *scene) {
        .  
        .    float r = 0;
        .    float g = 0;
        .    float b = 0;
        .  
4,620,582    Vec3<float> point = ray.getOrigin() + ray.getDirection()*distance;
1,283,030  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getOrigin() const (256606x)
1,283,030  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (256606x)
1,283,495    list<DirectionalLight> lights = scene->visibleLights(point);
405,192,918  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::visibleLights(Vec3<float>) (256606x)
        .    //list<DirectionalLight> lights = scene->getDirectionalLights();
        .    
        .  
        .    float diffuse;
        .    float specular;
        .    
3,593,786    Color ambientColor = (scene->getAmbientLight()).getColor();
1,283,030  => /home/guillaume/dev/pray/client/src/light.cpp:Light::getColor() (256606x)
1,283,030  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getAmbientLight() (256606x)
        .  
        .    float rr;
        .    float rg;
        .    float rb;
        .    
3,850,485    r += color.getR()*ambiantReflection*ambientColor.getR();
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (513212x)
3,337,087    g += color.getG()*ambiantReflection*ambientColor.getG();
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (513212x)
3,080,388    b += color.getB()*ambiantReflection*ambientColor.getB();
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (513212x)
        .  
1,207,766    for(DirectionalLight l : lights) {
        .  
1,388,736      diffuse = diffuseReflection*fabs(l.getDirection().scalar(normal));
  385,640  => /home/guillaume/dev/pray/client/src/directionalLight.cpp:DirectionalLight::getDirection() (77128x)
2,700,320      specular = specularReflection*fabs(pow(l.getDirection().symmetry(normal).scalar(ray.getDirection()*(-1)), shininess));
33,488,100  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/math/w_pow.c:pow (77128x)
  385,640  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (77128x)
  385,640  => /home/guillaume/dev/pray/client/src/directionalLight.cpp:DirectionalLight::getDirection() (77128x)
        .  
  771,520      rr = l.getColor().getR();
  385,640  => /home/guillaume/dev/pray/client/src/light.cpp:Light::getColor() (77128x)
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (77128x)
  771,520      rg = l.getColor().getG();
  385,640  => /home/guillaume/dev/pray/client/src/light.cpp:Light::getColor() (77128x)
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (77128x)
  771,520      rb = l.getColor().getB();
  385,640  => /home/guillaume/dev/pray/client/src/light.cpp:Light::getColor() (77128x)
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (77128x)
        .  
  540,064      r += color.getR()*diffuse*rr;
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (77128x)
  540,064      g += color.getG()*diffuse*rg;
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (77128x)
  462,912      b += color.getB()*diffuse*rb;
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (77128x)
        .  
  771,520      r += color.getR()*specular*rr;
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (77128x)
  771,520      g += color.getG()*specular*rg;
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (77128x)
  540,064      b += color.getB()*specular*rb;
  154,256  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (77128x)
        .   
        .    }
        .  
        .  
1,283,495    Color black = Color(0,0,0);
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float, float, float) (256606x)
        .    Ray reflectedRay = Ray(ray.getOrigin(),
2,566,990  			 ray.getDirection().symmetry(normal),
1,283,030  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getDirection() const (256606x)
3,850,485  			 black);
1,283,030  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::getOrigin() const (256606x)
8,981,210  => /home/guillaume/dev/pray/client/src/ray.cpp:Ray::Ray(Vec3<float> const&, Vec3<float> const&, Color&) (256606x)
2,053,592    Color reflectedColor = scene->renderRay(reflectedRay);
358,288,917  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::renderRay(Ray&) (256606x)
        .  
3,080,388    r += reflectivity*color.getR()*reflectedColor.getR();
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getR() (513212x)
3,080,388    g += reflectivity*color.getG()*reflectedColor.getG();
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getG() (513212x)
2,823,689    b += reflectivity*color.getB()*reflectedColor.getB();
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::getB() (513212x)
        .   
        .  
  256,699    if(r>1) {
1,796,893      r=1;
        .    }
        .    if(g>1) {
1,026,796      g=1;
        .    }
        .    if(b>1) {
        .      b=1;
        .    }  
        .  
2,310,291    return Color(r, g, b);
1,026,424  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float, float, float) (256606x)
        .  
2,823,691  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/SDL-1.2.14/src/video/SDL_blit_N.c
--------------------------------------------------------------------------------
        Ir 

-- line 2027 ----------------------------------------
         .  			width);
         .  			src = (Uint32*)((Uint8*)src + srcskip);
         .  			dst = (Uint32*)((Uint8*)dst + dstskip);
         .  		}
         .  	}
         .  }
         .  
         .  static void BlitNtoN(SDL_BlitInfo *info)
         6  {
         1  	int width = info->d_width;
         1  	int height = info->d_height;
         1  	Uint8 *src = info->s_pixels;
         1  	int srcskip = info->s_skip;
         1  	Uint8 *dst = info->d_pixels;
         1  	int dstskip = info->d_skip;
         1  	SDL_PixelFormat *srcfmt = info->src;
         1  	int srcbpp = srcfmt->BytesPerPixel;
         1  	SDL_PixelFormat *dstfmt = info->dst;
         1  	int dstbpp = dstfmt->BytesPerPixel;
         4  	unsigned alpha = dstfmt->Amask ? srcfmt->alpha : 0;
         .  
     2,179  	while ( height-- ) {
52,421,761  		DUFFS_LOOP(
         .  		{
         .  		        Uint32 Pixel;
         .  			unsigned sR;
         .  			unsigned sG;
         .  			unsigned sB;
         .  			DISEMBLE_RGB(src, srcbpp, srcfmt, Pixel, sR, sG, sB);
         .  			ASSEMBLE_RGBA(dst, dstbpp, dstfmt, sR, sG, sB, alpha);
         .  			dst += dstbpp;
         .  			src += srcbpp;
         .  		},
         .  		width);
       720  		src += srcskip;
       720  		dst += dstskip;
         .  	}
         7  }
         .  
         .  static void BlitNtoNCopyAlpha(SDL_BlitInfo *info)
         .  {
         .  	int width = info->d_width;
         .  	int height = info->d_height;
         .  	Uint8 *src = info->s_pixels;
         .  	int srcskip = info->s_skip;
         .  	Uint8 *dst = info->d_pixels;
-- line 2072 ----------------------------------------
-- line 2366 ----------------------------------------
         .  };
         .  static const struct blit_table *normal_blit[] = {
         .  	normal_blit_1, normal_blit_2, normal_blit_3, normal_blit_4
         .  };
         .  
         .  /* Mask matches table, or table entry is zero */
         .  #define MASKOK(x, y) (((x) == (y)) || ((y) == 0x00000000))
         .  
         2  SDL_loblit SDL_CalculateBlitN(SDL_Surface *surface, int blit_index)
         7  {
         .  	struct private_swaccel *sdata;
         .  	SDL_PixelFormat *srcfmt;
         .  	SDL_PixelFormat *dstfmt;
         .  	const struct blit_table *table;
         .  	int which;
         .  	SDL_loblit blitfun;
         .  
         .  	/* Set up data for choosing the blit */
         2  	sdata = surface->map->sw_data;
         1  	srcfmt = surface->format;
         2  	dstfmt = surface->map->dst->format;
         .  
         2  	if ( blit_index & 2 ) {
         .  	        /* alpha or alpha+colorkey */
         .  	        return SDL_CalculateAlphaBlit(surface, blit_index);
         .  	}
         .  
         .  	/* We don't support destinations less than 8-bits */
         3  	if ( dstfmt->BitsPerPixel < 8 ) {
         1  		return(NULL);
         .  	}
         .  	
         2  	if(blit_index == 1) {
         .  	    /* colorkey blit: Here we don't have too many options, mostly
         .  	       because RLE is the preferred fast way to deal with this.
         .  	       If a particular case turns out to be useful we'll add it. */
         .  
         .  	    if(srcfmt->BytesPerPixel == 2
         .  	       && surface->map->identity)
         .  		return Blit2to2Key;
         .  	    else if(dstfmt->BytesPerPixel == 1)
-- line 2406 ----------------------------------------
-- line 2415 ----------------------------------------
         .  		if(srcfmt->Amask && dstfmt->Amask)
         .  		    return BlitNtoNKeyCopyAlpha;
         .  		else
         .  		    return BlitNtoNKey;
         .  	    }
         .  	}
         .  
         .  	blitfun = NULL;
         2  	if ( dstfmt->BitsPerPixel == 8 ) {
         .  		/* We assume 8-bit destinations are palettized */
         .  		if ( (srcfmt->BytesPerPixel == 4) &&
         .  		     (srcfmt->Rmask == 0x00FF0000) &&
         .  		     (srcfmt->Gmask == 0x0000FF00) &&
         .  		     (srcfmt->Bmask == 0x000000FF) ) {
         .  			if ( surface->map->table ) {
         .  				blitfun = Blit_RGB888_index8_map;
         .  			} else {
-- line 2431 ----------------------------------------
-- line 2436 ----------------------------------------
         .  				blitfun = Blit_RGB888_index8;
         .  #endif
         .  			}
         .  		} else {
         .  			blitfun = BlitNto1;
         .  		}
         .  	} else {
         .  		/* Now the meat, choose the blitter we want */
         1  		int a_need = NO_ALPHA;
         3  		if(dstfmt->Amask)
         .  		    a_need = srcfmt->Amask ? COPY_ALPHA : SET_ALPHA;
         5  		table = normal_blit[srcfmt->BytesPerPixel-1];
        13  		for ( which=0; table[which].dstbpp; ++which ) {
        10  			if ( MASKOK(srcfmt->Rmask, table[which].srcR) &&
         6  			    MASKOK(srcfmt->Gmask, table[which].srcG) &&
         6  			    MASKOK(srcfmt->Bmask, table[which].srcB) &&
         6  			    MASKOK(dstfmt->Rmask, table[which].dstR) &&
         .  			    MASKOK(dstfmt->Gmask, table[which].dstG) &&
         .  			    MASKOK(dstfmt->Bmask, table[which].dstB) &&
         .  			    dstfmt->BytesPerPixel == table[which].dstbpp &&
         .  			    (a_need & table[which].alpha) == a_need &&
         .  			    ((table[which].blit_features & GetBlitFeatures()) == table[which].blit_features) )
         .  				break;
         .  		}
         2  		sdata->aux_data = table[which].aux_data;
         1  		blitfun = table[which].blitfunc;
         .  
         3  		if(blitfun == BlitNtoN) {  /* default C fallback catch-all. Slow! */
         .  			/* Fastpath C fallback: 32bit RGB<->RGBA blit with matching RGB */
         4  			if ( srcfmt->BytesPerPixel == 4 && dstfmt->BytesPerPixel == 4 &&
         .  			     srcfmt->Rmask == dstfmt->Rmask &&
         .  			     srcfmt->Gmask == dstfmt->Gmask &&
         .  			     srcfmt->Bmask == dstfmt->Bmask ) {
         .  				blitfun = Blit4to4MaskAlpha;
         .  			} else if ( a_need == COPY_ALPHA ) {
         4  			    blitfun = BlitNtoNCopyAlpha;
         .  			}
         .  		}
         .  	}
         .  
         .  #ifdef DEBUG_ASM
         .  #if SDL_HERMES_BLITTERS
         .  	if ( blitfun == ConvertMMX )
         .  		fprintf(stderr, "Using mmx blit\n");
-- line 2479 ----------------------------------------
-- line 2484 ----------------------------------------
         .  #endif
         .  	if ( (blitfun == BlitNtoN) || (blitfun == BlitNto1) )
         .  		fprintf(stderr, "Using C blit\n");
         .  	else
         .  		fprintf(stderr, "Using optimized C blit\n");
         .  #endif /* DEBUG_ASM */
         .  
         .  	return(blitfun);
         8  }

--------------------------------------------------------------------------------
-- Auto-annotated source: src/ray.cpp
--------------------------------------------------------------------------------
         Ir 

          .  #include "ray.h"
          .  
  1,691,697  Ray::Ray(const Vec3<float> &origin, const Vec3<float> &direction, Color &color) :
 18,608,667    origin(origin), direction(direction.normalize()), color(color)
          .  {
          .  
  3,383,394  }
          .  
          .  Vec3<float> Ray::getOrigin() const {
 44,301,582    return origin;
 29,534,388  }
          .  
          .  Vec3<float> Ray::getDirection() const {
129,641,331    return direction;
 86,427,554  }
          .  
          .  Color Ray::getColor() const {
          .    return color;
          .  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c
--------------------------------------------------------------------------------
     Ir 

-- line 1906 ----------------------------------------
      .  */
      .  
      .  static void malloc_init_state(mstate av)
      .  {
      .    int     i;
      .    mbinptr bin;
      .  
      .    /* Establish circular links for normal bins */
    254    for (i = 1; i < NBINS; ++i) {
    127      bin = bin_at(av,i);
    381      bin->fd = bin->bk = bin;
      .    }
      .  
      .  #if MORECORE_CONTIGUOUS
      3    if (av != &main_arena)
      .  #endif
      .      set_noncontiguous(av);
      .    if (av == &main_arena)
      3      set_max_fast(DEFAULT_MXFAST);
      2    av->flags |= FASTCHUNKS_BIT;
      .  
      3    av->top            = initial_top(av);
      .  }
      .  
      .  /*
      .     Other internal utilities operating on mstates
      .  */
      .  
      .  static void*  sYSMALLOc(INTERNAL_SIZE_T, mstate);
      .  static int      sYSTRIm(size_t, mstate);
-- line 1935 ----------------------------------------
-- line 2364 ----------------------------------------
      .    char*           aligned_brk;    /* aligned offset into brk */
      .  
      .    mchunkptr       p;              /* the allocated/returned chunk */
      .    mchunkptr       remainder;      /* remainder from allocation */
      .    unsigned long   remainder_size; /* its size */
      .  
      .    unsigned long   sum;            /* for updating stats */
      .  
     35    size_t          pagemask  = GLRO(dl_pagesize) - 1;
      7    bool            tried_mmap = false;
      .  
      .  
      .    /*
      .      If have mmap, and the request size meets the mmap threshold, and
      .      the system supports mmap, and there are few enough currently
      .      allocated mmapped regions, try to directly map this request
      .      rather than expanding top.
      .    */
      .  
     23    if ((unsigned long)(nb) >= (unsigned long)(mp_.mmap_threshold) &&
      .        (mp_.n_mmaps < mp_.n_mmaps_max)) {
      .  
      .      char* mm;             /* return value from mmap call*/
      .  
      .    try_mmap:
      .      /*
      .        Round up size to nearest page.  For mmapped chunks, the overhead
      .        is one SIZE_SZ unit larger than for normal chunks, because there
      .        is no following chunk whose prev_size field could be used.
      .  
      .        See the front_misalign handling below, for glibc there is no
      .        need for further alignments.  */
     15      size = (nb + SIZE_SZ + pagemask) & ~pagemask;
      .      tried_mmap = true;
      .  
      .      /* Don't try if size wraps around 0 */
      6      if ((unsigned long)(size) > (unsigned long)(nb)) {
      .  
     24        mm = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));
     18  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/misc/../sysdeps/unix/syscall-template.S:mmap (3x)
      .  
      9        if (mm != MAP_FAILED) {
      .  
      .  	/*
      .  	  The offset to the start of the mmapped region is stored
      .  	  in the prev_size field of the chunk. This allows us to adjust
      .  	  returned start address to meet alignment requirements here
      .  	  and in memalign(), and still be able to compute proper
      .  	  address argument for later munmap in free() and realloc().
      .  
      .  	  For glibc, chunk2mem increases the address by 2*SIZE_SZ and
      .  	  MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page
      .  	  aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */
      9  	assert (((INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK) == 0);
      .  
      .  	p = (mchunkptr)mm;
      9  	set_head(p, size|IS_MMAPPED);
      .  
      .  	/* update statistics */
      .  
     15  	if (++mp_.n_mmaps > mp_.max_n_mmaps)
      2  	  mp_.max_n_mmaps = mp_.n_mmaps;
      .  
      6  	sum = mp_.mmapped_mem += size;
      6  	if (sum > (unsigned long)(mp_.max_mmapped_mem))
      6  	  mp_.max_mmapped_mem = sum;
      .  
      .  	check_chunk(av, p);
      .  
      .  	return chunk2mem(p);
      .        }
      .      }
      .    }
      .  
      .    /* Record incoming configuration of top */
      .  
      .    old_top  = av->top;
      .    old_size = chunksize(old_top);
      8    old_end  = (char*)(chunk_at_offset(old_top, old_size));
      .  
      .    brk = snd_brk = (char*)(MORECORE_FAILURE);
      .  
      .    /*
      .       If not the first time through, we require old_size to be
      .       at least MINSIZE and to have prev_inuse set.
      .    */
      .  
     35    assert((old_top == initial_top(av) && old_size == 0) ||
      .  	 ((unsigned long) (old_size) >= MINSIZE &&
      .  	  prev_inuse(old_top) &&
      .  	  ((unsigned long)old_end & pagemask) == 0));
      .  
      .    /* Precondition: not enough current space to satisfy nb request */
      6    assert((unsigned long)(old_size) < (unsigned long)(nb + MINSIZE));
      .  
      .  
     12    if (av != &main_arena) {
      .  
      .      heap_info *old_heap, *heap;
      .      size_t old_heap_size;
      .  
      .      /* First try to extend the current heap. */
      .      old_heap = heap_for_ptr(old_top);
      .      old_heap_size = old_heap->size;
      .      if ((long) (MINSIZE + nb - old_size) > 0
-- line 2467 ----------------------------------------
-- line 2501 ----------------------------------------
      .        /* We can at least try to use to mmap memory.  */
      .        goto try_mmap;
      .  
      .    } else { /* av == main_arena */
      .  
      .  
      .    /* Request enough space for nb + pad + overhead */
      .  
     24    size = nb + mp_.top_pad + MINSIZE;
      .  
      .    /*
      .      If contiguous, we can subtract out existing space that we hope to
      .      combine with new space. We add it back later only if
      .      we don't actually get contiguous space.
      .    */
      .  
      4    if (contiguous(av))
      .      size -= old_size;
      .  
      .    /*
      .      Round to a multiple of page size.
      .      If MORECORE is not contiguous, this ensures that we only call it
      .      with whole-page arguments.  And if MORECORE is contiguous and
      .      this is not first time through, this preserves page-alignment of
      .      previous calls. Otherwise, we correct to page-align below.
      .    */
      .  
     28    size = (size + pagemask) & ~pagemask;
      .  
      .    /*
      .      Don't try to call MORECORE if argument is so big as to appear
      .      negative. Note that since mmap takes size_t arg, it may succeed
      .      below even if we cannot call MORECORE.
      .    */
      .  
      8    if (size > 0)
     24      brk = (char*)(MORECORE(size));
    261  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/morecore.c:__default_morecore (4x)
      .  
     24    if (brk != (char*)(MORECORE_FAILURE)) {
      .      /* Call the `morecore' hook if necessary.  */
      8      void (*hook) (void) = force_reg (__after_morecore_hook);
      8      if (__builtin_expect (hook != NULL, 0))
      .        (*hook) ();
      .    } else {
      .    /*
      .      If have mmap, try using it as a backup when MORECORE fails or
      .      cannot be used. This is worth doing on systems that have "holes" in
      .      address space, so sbrk cannot extend to give contiguous space, but
      .      space is available elsewhere.  Note that we ignore mmap max count
      .      and threshold limits, since the space will not be used as a
-- line 2550 ----------------------------------------
-- line 2551 ----------------------------------------
      .      segregated mmap region.
      .    */
      .  
      .      /* Cannot merge with old top, so add its size back in */
      .      if (contiguous(av))
      .        size = (size + old_size + pagemask) & ~pagemask;
      .  
      .      /* If we are relying on mmap as backup, then use larger units */
      8      if ((unsigned long)(size) < (unsigned long)(MMAP_AS_MORECORE_SIZE))
      .        size = MMAP_AS_MORECORE_SIZE;
      .  
      .      /* Don't try if size wraps around 0 */
      .      if ((unsigned long)(size) > (unsigned long)(nb)) {
      .  
      .        char *mbrk = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));
      .  
      .        if (mbrk != MAP_FAILED) {
-- line 2567 ----------------------------------------
-- line 2577 ----------------------------------------
      .  	   bridge regions.
      .  	*/
      .  	set_noncontiguous(av);
      .        }
      .      }
      .    }
      .  
      .    if (brk != (char*)(MORECORE_FAILURE)) {
      8      if (mp_.sbrk_base == 0)
      1        mp_.sbrk_base = brk;
     12      av->system_mem += size;
      .  
      .      /*
      .        If MORECORE extends previous space, we can likewise extend top size.
      .      */
      .  
     14      if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE))
     18        set_head(old_top, (size + old_size) | PREV_INUSE);
      .  
      4      else if (contiguous(av) && old_size && brk < old_end) {
      .        /* Oops!  Someone else killed our space..  Can't touch anything.  */
      .        mutex_unlock(&av->mutex);
      .        malloc_printerr (3, "break adjusted to free malloc space", brk);
      .        mutex_lock(&av->mutex);
      .      }
      .  
      .      /*
      .        Otherwise, make adjustments:
-- line 2604 ----------------------------------------
-- line 2621 ----------------------------------------
      .  
      .      else {
      .        front_misalign = 0;
      .        end_misalign = 0;
      .        correction = 0;
      .        aligned_brk = brk;
      .  
      .        /* handle contiguous cases */
      2        if (contiguous(av)) {
      .  
      .  	/* Count foreign sbrk as system_mem.  */
      .  	if (old_size)
      .  	  av->system_mem += brk - old_end;
      .  
      .  	/* Guarantee alignment of first new chunk made from this space */
      .  
      .  	front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) & MALLOC_ALIGN_MASK;
      5  	if (front_misalign > 0) {
      .  
      .  	  /*
      .  	    Skip over some bytes to arrive at an aligned position.
      .  	    We don't need to specially mark these wasted front bytes.
      .  	    They will never be accessed anyway because
      .  	    prev_inuse of av->top (and any chunk created from its start)
      .  	    is always true after initialization.
      .  	  */
-- line 2646 ----------------------------------------
-- line 2649 ----------------------------------------
      .  	  aligned_brk += correction;
      .  	}
      .  
      .  	/*
      .  	  If this isn't adjacent to existing space, then we will not
      .  	  be able to merge with old_top space, so must add to 2nd request.
      .  	*/
      .  
      1  	correction += old_size;
      .  
      .  	/* Extend the end address to hit a page boundary */
      2  	end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);
      4  	correction += ((end_misalign + pagemask) & ~pagemask) - end_misalign;
      .  
      2  	assert(correction >= 0);
      4  	snd_brk = (char*)(MORECORE(correction));
     46  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/morecore.c:__default_morecore (1x)
      .  
      .  	/*
      .  	  If can't allocate correction, try to at least find out current
      .  	  brk.  It might be enough to proceed without failing.
      .  
      .  	  Note that if second sbrk did NOT fail, we assume that space
      .  	  is contiguous with first sbrk. This is a safe assumption unless
      .  	  program is multithreaded but doesn't use locks and a foreign sbrk
      .  	  occurred between our first and second calls.
      .  	*/
      .  
      3  	if (snd_brk == (char*)(MORECORE_FAILURE)) {
      .  	  correction = 0;
      .  	  snd_brk = (char*)(MORECORE(0));
      .  	} else {
      .  	  /* Call the `morecore' hook if necessary.  */
      2  	  void (*hook) (void) = force_reg (__after_morecore_hook);
      2  	  if (__builtin_expect (hook != NULL, 0))
      .  	    (*hook) ();
      .  	}
      .        }
      .  
      .        /* handle non-contiguous cases */
      .        else {
      .  	/* MORECORE/mmap must correctly align */
      .  	assert(((unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK) == 0);
-- line 2690 ----------------------------------------
-- line 2691 ----------------------------------------
      .  
      .  	/* Find out current end of memory */
      .  	if (snd_brk == (char*)(MORECORE_FAILURE)) {
      .  	  snd_brk = (char*)(MORECORE(0));
      .  	}
      .        }
      .  
      .        /* Adjust top based on results of second sbrk */
      1        if (snd_brk != (char*)(MORECORE_FAILURE)) {
      1  	av->top = (mchunkptr)aligned_brk;
      4  	set_head(av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
      2  	av->system_mem += correction;
      .  
      .  	/*
      .  	  If not the first time through, we either have a
      .  	  gap due to foreign sbrk or a non-contiguous region.  Insert a
      .  	  double fencepost at old_top to prevent consolidation with space
      .  	  we don't own. These fenceposts are artificial chunks that are
      .  	  marked as inuse and are in any case too small to use.  We need
      .  	  two to make sizes and alignments work out.
      .  	*/
      .  
      2  	if (old_size != 0) {
      .  	  /*
      .  	     Shrink old_top to insert fenceposts, keeping size a
      .  	     multiple of MALLOC_ALIGNMENT. We know there is at least
      .  	     enough space in old_top to do this.
      .  	  */
      .  	  old_size = (old_size - 4*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      .  	  set_head(old_top, old_size | PREV_INUSE);
      .  
-- line 2721 ----------------------------------------
-- line 2727 ----------------------------------------
      .  	  */
      .  	  chunk_at_offset(old_top, old_size            )->size =
      .  	    (2*SIZE_SZ)|PREV_INUSE;
      .  
      .  	  chunk_at_offset(old_top, old_size + 2*SIZE_SZ)->size =
      .  	    (2*SIZE_SZ)|PREV_INUSE;
      .  
      .  	  /* If possible, release the rest. */
      2  	  if (old_size >= MINSIZE) {
      .  	    _int_free(av, old_top, 1);
      .  	  }
      .  
      .  	}
      .        }
      .      }
      .    }
      .  
      .    } /* if (av !=  &main_arena) */
      .  
      8    if ((unsigned long)av->system_mem > (unsigned long)(av->max_system_mem))
      4      av->max_system_mem = av->system_mem;
      .    check_malloc_state(av);
      .  
      .    /* finally, do the allocation */
      .    p = av->top;
      8    size = chunksize(p);
      .  
      .    /* check that one of the above allocation paths succeeded */
      8    if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
      4      remainder_size = size - nb;
      4      remainder = chunk_at_offset(p, nb);
      4      av->top = remainder;
     32      set_head(p, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0));
      8      set_head(remainder, remainder_size | PREV_INUSE);
      .      check_malloced_chunk(av, p, nb);
      4      return chunk2mem(p);
      .    }
      .  
      .    /* catch all failure paths */
      .    __set_errno (ENOMEM);
      .    return 0;
      .  }
      .  
      .  
-- line 2770 ----------------------------------------
-- line 2772 ----------------------------------------
      .    sYSTRIm is an inverse of sorts to sYSMALLOc.  It gives memory back
      .    to the system (via negative arguments to sbrk) if there is unused
      .    memory at the `high' end of the malloc pool. It is called
      .    automatically by free() when top space exceeds the trim
      .    threshold. It is also called by the public malloc_trim routine.  It
      .    returns 1 if it actually released any memory, else 0.
      .  */
      .  
     18  static int sYSTRIm(size_t pad, mstate av)
      .  {
      .    long  top_size;        /* Amount of top-most memory */
      .    long  extra;           /* Amount to release */
      .    long  released;        /* Amount actually released */
      .    char* current_brk;     /* address returned by pre-check sbrk call */
      .    char* new_brk;         /* address returned by post-check sbrk call */
      .    size_t pagesz;
      .  
      2    pagesz = GLRO(dl_pagesize);
      6    top_size = chunksize(av->top);
      .  
      .    /* Release in pagesize units, keeping at least one page */
     10    extra = (top_size - pad - MINSIZE - 1) & ~(pagesz - 1);
      .  
      6    if (extra > 0) {
      .  
      .      /*
      .        Only proceed if end of memory is where we last set it.
      .        This avoids problems if there were foreign sbrk calls.
      .      */
      8      current_brk = (char*)(MORECORE(0));
     92  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/morecore.c:__default_morecore (2x)
      8      if (current_brk == (char*)(av->top) + top_size) {
      .  
      .        /*
      .  	Attempt to release memory. We ignore MORECORE return value,
      .  	and instead call again to find out where new end of memory is.
      .  	This avoids problems if first call releases less than we asked,
      .  	of if failure somehow altered brk value. (We could still
      .  	encounter problems if it altered brk in some very bad way,
      .  	but the only thing we can do is adjust anyway, which will cause
      .  	some downstream failure.)
      .        */
      .  
      6        MORECORE(-extra);
    138  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/morecore.c:__default_morecore (2x)
      .        /* Call the `morecore' hook if necessary.  */
      4        void (*hook) (void) = force_reg (__after_morecore_hook);
      4        if (__builtin_expect (hook != NULL, 0))
      .  	(*hook) ();
      4        new_brk = (char*)(MORECORE(0));
     92  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/morecore.c:__default_morecore (2x)
      .  
      4        if (new_brk != (char*)MORECORE_FAILURE) {
      .  	released = (long)(current_brk - new_brk);
      .  
      4  	if (released != 0) {
      .  	  /* Success. Adjust top. */
      2  	  av->system_mem -= released;
     10  	  set_head(av->top, (top_size - released) | PREV_INUSE);
      .  	  check_malloc_state(av);
      2  	  return 1;
      .  	}
      .        }
      .      }
      .    }
      4    return 0;
     18  }
      .  
      .  static void
      .  internal_function
      .  munmap_chunk(mchunkptr p)
      3  {
      9    INTERNAL_SIZE_T size = chunksize(p);
      .  
      6    assert (chunk_is_mmapped(p));
      .  
      9    uintptr_t block = (uintptr_t) p - p->prev_size;
      3    size_t total_size = p->prev_size + size;
      .    /* Unfortunately we have to do the compilers job by hand here.  Normally
      .       we would test BLOCK and TOTAL-SIZE separately for compliance with the
      .       page size.  But gcc does not recognize the optimization possibility
      .       (in the moment at least) so we combine the two values into one before
      .       the bit test.  */
     21    if (__builtin_expect (((block | total_size) & (GLRO(dl_pagesize) - 1)) != 0, 0))
      .      {
      .        malloc_printerr (check_action, "munmap_chunk(): invalid pointer",
      .  		       chunk2mem (p));
      .        return;
      .      }
      .  
      3    mp_.n_mmaps--;
      3    mp_.mmapped_mem -= total_size;
      .  
      6    int ret __attribute__ ((unused)) = munmap((char *)block, total_size);
     15  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/misc/../sysdeps/unix/syscall-template.S:munmap (3x)
      .  
      .    /* munmap returns non-zero on failure */
      6    assert(ret == 0);
      6  }
      .  
      .  #if HAVE_MREMAP
      .  
      .  static mchunkptr
      .  internal_function
      .  mremap_chunk(mchunkptr p, size_t new_size)
      8  {
      6    size_t page_mask = GLRO(dl_pagesize) - 1;
      2    INTERNAL_SIZE_T offset = p->prev_size;
      4    INTERNAL_SIZE_T size = chunksize(p);
      .    char *cp;
      .  
      4    assert (chunk_is_mmapped(p));
      6    assert(((size + offset) & (GLRO(dl_pagesize)-1)) == 0);
      .  
      .    /* Note the extra SIZE_SZ overhead as in mmap_chunk(). */
      8    new_size = (new_size + offset + SIZE_SZ + page_mask) & ~page_mask;
      .  
      .    /* No need to remap if the number of pages does not change.  */
      4    if (size + offset == new_size)
      .      return p;
      .  
     12    cp = (char *)mremap((char *)p - offset, size + offset, new_size,
     12  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/misc/../sysdeps/unix/syscall-template.S:mremap (2x)
      .  		      MREMAP_MAYMOVE);
      .  
      4    if (cp == MAP_FAILED) return 0;
      .  
      2    p = (mchunkptr)(cp + offset);
      .  
      4    assert(aligned_OK(chunk2mem(p)));
      .  
      6    assert((p->prev_size == offset));
     10    set_head(p, (new_size - offset)|IS_MMAPPED);
      .  
      2    mp_.mmapped_mem -= size + offset;
      4    mp_.mmapped_mem += new_size;
      4    if ((unsigned long)mp_.mmapped_mem > (unsigned long)mp_.max_mmapped_mem)
      2      mp_.max_mmapped_mem = mp_.mmapped_mem;
      .    return p;
     12  }
      .  
      .  #endif /* HAVE_MREMAP */
      .  
      .  /*------------------------ Public wrappers. --------------------------------*/
      .  
      .  void*
      .  public_mALLOc(size_t bytes)
552,342  {
      .    mstate ar_ptr;
      .    void *victim;
      .  
      .    __malloc_ptr_t (*hook) (size_t, __const __malloc_ptr_t)
184,114      = force_reg (__malloc_hook);
184,114    if (__builtin_expect (hook != NULL, 0))
      2      return (*hook)(bytes, RETURN_ADDRESS (0));
 59,230  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/hooks.c:malloc_hook_ini (1x)
      .  
184,112    arena_lookup(ar_ptr);
      .  
828,504    arena_lock(ar_ptr, bytes);
      .    if(!ar_ptr)
      .      return 0;
368,224    victim = _int_malloc(ar_ptr, bytes);
5,399,930  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_malloc (92055x)
184,112    if(!victim) {
      .      /* Maybe the failure is due to running out of mmapped areas. */
      .      if(ar_ptr != &main_arena) {
      .        (void)mutex_unlock(&ar_ptr->mutex);
      .        ar_ptr = &main_arena;
      .        (void)mutex_lock(&ar_ptr->mutex);
      .        victim = _int_malloc(ar_ptr, bytes);
      .        (void)mutex_unlock(&ar_ptr->mutex);
      .      } else {
-- line 2937 ----------------------------------------
-- line 2939 ----------------------------------------
      .        ar_ptr = arena_get2(ar_ptr->next ? ar_ptr : 0, bytes);
      .        (void)mutex_unlock(&main_arena.mutex);
      .        if(ar_ptr) {
      .  	victim = _int_malloc(ar_ptr, bytes);
      .  	(void)mutex_unlock(&ar_ptr->mutex);
      .        }
      .      }
      .    } else
368,224      (void)mutex_unlock(&ar_ptr->mutex);
736,438    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||
      .  	 ar_ptr == arena_for_chunk(mem2chunk(victim)));
      .    return victim;
644,397  }
      .  libc_hidden_def(public_mALLOc)
      .  
      .  void
      .  public_fREe(void* mem)
      .  {
      .    mstate ar_ptr;
      .    mchunkptr p;                          /* chunk corresponding to mem */
      .  
      .    void (*hook) (__malloc_ptr_t, __const __malloc_ptr_t)
183,300      = force_reg (__free_hook);
183,300    if (__builtin_expect (hook != NULL, 0)) {
      .      (*hook)(mem, RETURN_ADDRESS (0));
      .      return;
      .    }
      .  
183,300    if (mem == 0)                              /* free(0) has no effect */
      .      return;
      .  
 91,619    p = mem2chunk(mem);
      .  
274,857    if (chunk_is_mmapped(p))                       /* release mmapped memory. */
      .    {
      .      /* see if the dynamic brk/mmap threshold needs adjusting */
      9      if (!mp_.no_dyn_threshold
      6  	&& p->size > mp_.mmap_threshold
      4  	&& p->size <= DEFAULT_MMAP_THRESHOLD_MAX)
      .        {
      4  	mp_.mmap_threshold = chunksize (p);
      4  	mp_.trim_threshold = 2 * mp_.mmap_threshold;
      .        }
     37      munmap_chunk(p);
     90  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:munmap_chunk (3x)
      .      return;
      .    }
      .  
274,848    ar_ptr = arena_for_chunk(p);
183,232    _int_free(ar_ptr, p, 0);
6,316,451  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_free (91616x)
      .  }
      .  libc_hidden_def (public_fREe)
      .  
      .  void*
      .  public_rEALLOc(void* oldmem, size_t bytes)
  2,403  {
      .    mstate ar_ptr;
      .    INTERNAL_SIZE_T    nb;      /* padded request size */
      .  
      .    void* newp;             /* chunk to return */
      .  
      .    __malloc_ptr_t (*hook) (__malloc_ptr_t, size_t, __const __malloc_ptr_t) =
    534      force_reg (__realloc_hook);
    534    if (__builtin_expect (hook != NULL, 0))
      2      return (*hook)(oldmem, bytes, RETURN_ADDRESS (0));
    209  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/hooks.c:realloc_hook_ini (1x)
      .  
      .  #if REALLOC_ZERO_BYTES_FREES
    532    if (bytes == 0 && oldmem != NULL) { public_fREe(oldmem); return 0; }
      .  #endif
      .  
      .    /* realloc of null is supposed to be same as malloc */
    790    if (oldmem == 0) return public_mALLOc(bytes);
 38,839  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc (129x)
      .  
      .    /* chunk corresponding to oldmem */
    137    const mchunkptr oldp    = mem2chunk(oldmem);
      .    /* its size */
    411    const INTERNAL_SIZE_T oldsize = chunksize(oldp);
      .  
      .    /* Little security check which won't hurt performance: the
      .       allocator never wrapps around at the end of the address space.
      .       Therefore we can exclude some size values which might appear
      .       here by accident or by "design" from some intruder.  */
    548    if (__builtin_expect ((uintptr_t) oldp > (uintptr_t) -oldsize, 0)
    274        || __builtin_expect (misaligned_chunk (oldp), 0))
      .      {
      .        malloc_printerr (check_action, "realloc(): invalid pointer", oldmem);
      .        return NULL;
      .      }
      .  
  1,096    checked_request2size(bytes, nb);
      .  
    274    if (chunk_is_mmapped(oldp))
      .    {
      .      void* newmem;
      .  
      .  #if HAVE_MREMAP
      6      newp = mremap_chunk(oldp, nb);
    116  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:mremap_chunk (2x)
      8      if(newp) return chunk2mem(newp);
      .  #endif
      .      /* Note the extra SIZE_SZ overhead. */
      .      if(oldsize - SIZE_SZ >= nb) return oldmem; /* do nothing */
      .      /* Must alloc, copy, free. */
      .      newmem = public_mALLOc(bytes);
      .      if (newmem == 0) return 0; /* propagate failure */
      .      MALLOC_COPY(newmem, oldmem, oldsize - 2*SIZE_SZ);
      .      munmap_chunk(oldp);
      .      return newmem;
      .    }
      .  
    405    ar_ptr = arena_for_chunk(oldp);
      .  #if THREAD_STATS
      .    if(!mutex_trylock(&ar_ptr->mutex))
      .      ++(ar_ptr->stat_lock_direct);
      .    else {
      .      (void)mutex_lock(&ar_ptr->mutex);
      .      ++(ar_ptr->stat_lock_wait);
      .    }
      .  #else
    810    (void)mutex_lock(&ar_ptr->mutex);
      .  #endif
      .  
      .  #if !defined PER_THREAD
      .    /* As in malloc(), remember this arena for the next allocation. */
      .    tsd_setspecific(arena_key, (void *)ar_ptr);
      .  #endif
      .  
    810    newp = _int_realloc(ar_ptr, oldp, oldsize, nb);
100,124  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_realloc (134x)
      .  
    540    (void)mutex_unlock(&ar_ptr->mutex);
  1,614    assert(!newp || chunk_is_mmapped(mem2chunk(newp)) ||
      .  	 ar_ptr == arena_for_chunk(mem2chunk(newp)));
      .  
      .    if (newp == NULL)
      .      {
      .        /* Try harder to allocate memory in other arenas.  */
      .        newp = public_mALLOc(bytes);
      .        if (newp != NULL)
      .  	{
      .  	  MALLOC_COPY (newp, oldmem, oldsize - SIZE_SZ);
      .  	  _int_free(ar_ptr, oldp, 0);
      .  	}
      .      }
      .  
      .    return newp;
  2,143  }
      .  libc_hidden_def (public_rEALLOc)
      .  
      .  void*
      .  public_mEMALIGn(size_t alignment, size_t bytes)
      .  {
      .    mstate ar_ptr;
      .    void *p;
      .  
-- line 3090 ----------------------------------------
-- line 3216 ----------------------------------------
      .    assert(!p || chunk_is_mmapped(mem2chunk(p)) ||
      .  	 ar_ptr == arena_for_chunk(mem2chunk(p)));
      .  
      .    return p;
      .  }
      .  
      .  void*
      .  public_cALLOc(size_t n, size_t elem_size)
    756  {
      .    mstate av;
      .    mchunkptr oldtop, p;
      .    INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;
      .    void* mem;
      .    unsigned long clearsize;
      .    unsigned long nclears;
      .    INTERNAL_SIZE_T* d;
      .  
      .    /* size_t is unsigned so the behavior on overflow is defined.  */
    216    bytes = n * elem_size;
      .  #define HALF_INTERNAL_SIZE_T \
      .    (((INTERNAL_SIZE_T) 1) << (8 * sizeof (INTERNAL_SIZE_T) / 2))
    540    if (__builtin_expect ((n | elem_size) >= HALF_INTERNAL_SIZE_T, 0)) {
      .      if (elem_size != 0 && bytes / elem_size != n) {
      .        __set_errno (ENOMEM);
      .        return 0;
      .      }
      .    }
      .  
      .    __malloc_ptr_t (*hook) __MALLOC_PMT ((size_t, __const __malloc_ptr_t)) =
    216      force_reg (__malloc_hook);
    216    if (__builtin_expect (hook != NULL, 0)) {
      .      sz = bytes;
      .      mem = (*hook)(sz, RETURN_ADDRESS (0));
      .      if(mem == 0)
      .        return 0;
      .      return memset(mem, 0, sz);
      .    }
      .  
      .    sz = bytes;
      .  
  1,080    arena_get(av, sz);
      .    if(!av)
      .      return 0;
      .  
      .    /* Check if we hand out the top chunk, in which case there may be no
      .       need to clear. */
      .  #if MORECORE_CLEARS
    108    oldtop = top(av);
    216    oldtopsize = chunksize(top(av));
      .  #if MORECORE_CLEARS < 2
      .    /* Only newly allocated memory is guaranteed to be cleared.  */
      .    if (av == &main_arena &&
      .        oldtopsize < mp_.sbrk_base + av->max_system_mem - (char *)oldtop)
      .      oldtopsize = (mp_.sbrk_base + av->max_system_mem - (char *)oldtop);
      .  #endif
    324    if (av != &main_arena)
      .      {
      .        heap_info *heap = heap_for_ptr (oldtop);
      .        if (oldtopsize < (char *) heap + heap->mprotect_size - (char *) oldtop)
      .  	oldtopsize = (char *) heap + heap->mprotect_size - (char *) oldtop;
      .      }
      .  #endif
    432    mem = _int_malloc(av, sz);
 24,323  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_malloc (108x)
      .  
      .    /* Only clearing follows, so we can unlock early. */
    432    (void)mutex_unlock(&av->mutex);
      .  
  1,080    assert(!mem || chunk_is_mmapped(mem2chunk(mem)) ||
      .  	 av == arena_for_chunk(mem2chunk(mem)));
      .  
      .    if (mem == 0) {
      .      /* Maybe the failure is due to running out of mmapped areas. */
      .      if(av != &main_arena) {
      .        (void)mutex_lock(&main_arena.mutex);
      .        mem = _int_malloc(&main_arena, sz);
      .        (void)mutex_unlock(&main_arena.mutex);
-- line 3291 ----------------------------------------
-- line 3306 ----------------------------------------
      .    /* Two optional cases in which clearing not necessary */
      .    if (chunk_is_mmapped (p))
      .      {
      .        if (__builtin_expect (perturb_byte, 0))
      .  	MALLOC_ZERO (mem, sz);
      .        return mem;
      .      }
      .  
    108    csz = chunksize(p);
      .  
      .  #if MORECORE_CLEARS
    540    if (perturb_byte == 0 && (p == oldtop && csz > oldtopsize)) {
      .      /* clear only the bytes from non-freshly-sbrked memory */
      .      csz = oldtopsize;
      .    }
      .  #endif
      .  
      .    /* Unroll clear of <= 36 bytes (72 if 8byte sizes).  We know that
      .       contents have an odd number of INTERNAL_SIZE_T-sized words;
      .       minimally 3.  */
      .    d = (INTERNAL_SIZE_T*)mem;
    108    clearsize = csz - SIZE_SZ;
    216    nclears = clearsize / sizeof(INTERNAL_SIZE_T);
    216    assert(nclears >= 3);
      .  
    216    if (nclears > 9)
    268      MALLOC_ZERO(d, clearsize);
 16,545  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/memset.S:__GI_memset (67x)
      .  
      .    else {
     41      *(d+0) = 0;
     41      *(d+1) = 0;
     41      *(d+2) = 0;
     82      if (nclears > 4) {
     23        *(d+3) = 0;
     23        *(d+4) = 0;
     46        if (nclears > 6) {
     18  	*(d+5) = 0;
     18  	*(d+6) = 0;
     36  	if (nclears > 8) {
     13  	  *(d+7) = 0;
     26  	  *(d+8) = 0;
      .  	}
      .        }
      .      }
      .    }
      .  
      .    return mem;
    972  }
      .  
      .  
      .  int
      .  public_mTRIm(size_t s)
      .  {
      .    int result = 0;
      .  
      .    if(__malloc_initialized < 0)
-- line 3361 ----------------------------------------
-- line 3411 ----------------------------------------
      .  }
      .  
      .  /*
      .    ------------------------------ malloc ------------------------------
      .  */
      .  
      .  static void*
      .  _int_malloc(mstate av, size_t bytes)
829,791  {
      .    INTERNAL_SIZE_T nb;               /* normalized request size */
      .    unsigned int    idx;              /* associated bin index */
      .    mbinptr         bin;              /* associated bin */
      .  
      .    mchunkptr       victim;           /* inspected/selected chunk */
      .    INTERNAL_SIZE_T size;             /* its size */
      .    int             victim_index;     /* its bin index */
      .  
-- line 3427 ----------------------------------------
-- line 3441 ----------------------------------------
      .      Convert request size to internal form by adding SIZE_SZ bytes
      .      overhead plus possibly more to obtain necessary alignment and/or
      .      to obtain a size of at least MINSIZE, the smallest allocatable
      .      size. Also, checked_request2size traps (returning 0) request sizes
      .      that are so large that they wrap around zero when padded and
      .      aligned.
      .    */
      .  
737,592    checked_request2size(bytes, nb);
      .  
      .    /*
      .      If the size qualifies as a fastbin, first check corresponding bin.
      .      This code is safe to execute even if av is not yet initialized, so we
      .      can try it without checking, which saves some time on this fast path.
      .    */
      .  
184,398    if ((unsigned long)(nb) <= (unsigned long)(get_max_fast ())) {
274,398      idx = fastbin_index(nb);
269,738      mfastbinptr* fb = &fastbin (av, idx);
 91,466      mchunkptr pp = *fb;
      .      do
      .        {
      .  	victim = pp;
182,932  	if (victim == NULL)
      .  	  break;
      .        }
534,816      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim->fd, victim))
267,408  	   != victim);
      .      if (victim != 0) {
445,680        if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
      .  	{
      .  	  errstr = "malloc(): memory corruption (fast)";
      .  	errout:
      .  	  mutex_unlock(&av->mutex);
      .  	  malloc_printerr (check_action, errstr, chunk2mem (victim));
      .  	  mutex_lock(&av->mutex);
      .  	  return NULL;
      .  	}
-- line 3478 ----------------------------------------
-- line 3487 ----------------------------------------
      .    /*
      .      If a small request, check regular bin.  Since these "smallbins"
      .      hold one size each, no searching within bins is necessary.
      .      (For a large request, we need to wait until unsorted chunks are
      .      processed to find best fit. But for small ones, fits are exact
      .      anyway, so we can check now, which is faster.)
      .    */
      .  
  6,126    if (in_smallbin_range(nb)) {
  8,946      idx = smallbin_index(nb);
  5,964      bin = bin_at(av,idx);
      .  
  8,946      if ( (victim = last(bin)) != bin) {
    120        if (victim == 0) /* initialization check */
      .  	malloc_consolidate(av);
      .        else {
     59  	bck = victim->bk;
    118  	if (__builtin_expect (bck->fd != victim, 0))
      .  	  {
      .  	    errstr = "malloc(): smallbin double linked list corrupted";
      .  	    goto errout;
      .  	  }
     59  	set_inuse_bit_at_offset(victim, nb);
     59  	bin->bk = bck;
     59  	bck->fd = bin;
      .  
    177  	if (av != &main_arena)
      .  	  victim->size |= NON_MAIN_ARENA;
      .  	check_malloced_chunk(av, victim, nb);
      .  	void *p = chunk2mem(victim);
      .  	if (__builtin_expect (perturb_byte, 0))
      .  	  alloc_perturb (p, bytes);
      .  	return p;
      .        }
      .      }
-- line 3521 ----------------------------------------
-- line 3528 ----------------------------------------
      .       fragmentation problems normally associated with fastbins.
      .       Also, in practice, programs tend to have runs of either small or
      .       large requests, but less often mixtures, so consolidation is not
      .       invoked all that often in most programs. And the programs that
      .       it is called frequently in otherwise tend to fragment.
      .    */
      .  
      .    else {
    759      idx = largebin_index(nb);
    324      if (have_fastchunks(av))
      .        malloc_consolidate(av);
      .    }
      .  
      .    /*
      .      Process recently freed or remaindered chunks, taking one only if
      .      it is exact fit, or, if this a small request, the chunk is remainder from
      .      the most recent non-exact fit.  Place other traversed chunks in
      .      bins.  Note that this step is the only place in any routine where
-- line 3545 ----------------------------------------
-- line 3549 ----------------------------------------
      .      near the end of malloc that we should have consolidated, so must
      .      do so and retry. This happens at most once, and only when we would
      .      otherwise need to expand memory to service a "small" request.
      .    */
      .  
      .    for(;;) {
      .  
      .      int iters = 0;
 16,808      while ( (victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
  1,238        bck = victim->bk;
  3,714        if (__builtin_expect (victim->size <= 2 * SIZE_SZ, 0)
  2,476  	  || __builtin_expect (victim->size > av->system_mem, 0))
      .  	{
      .  	  void *p = chunk2mem(victim);
      .  	  mutex_unlock(&av->mutex);
      .  	  malloc_printerr (check_action, "malloc(): memory corruption", p);
      .  	  mutex_lock(&av->mutex);
      .  	}
  1,238        size = chunksize(victim);
      .  
      .        /*
      .  	 If a small request, try to use last remainder if it is the
      .  	 only chunk in unsorted bin.  This helps promote locality for
      .  	 runs of consecutive small requests. This is the only
      .  	 exception to best-fit, and applies only when there is
      .  	 no exact fit for a small chunk.
      .        */
      .  
  4,548        if (in_smallbin_range(nb) &&
  1,856  	  bck == unsorted_chunks(av) &&
  2,396  	  victim == av->last_remainder &&
  6,008  	  (unsigned long)(size) > (unsigned long)(nb + MINSIZE)) {
      .  
      .  	/* split and reattach remainder */
    601  	remainder_size = size - nb;
    601  	remainder = chunk_at_offset(victim, nb);
  1,202  	unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
    601  	av->last_remainder = remainder;
  1,202  	remainder->bk = remainder->fd = unsorted_chunks(av);
  1,202  	if (!in_smallbin_range(remainder_size))
      .  	  {
    335  	    remainder->fd_nextsize = NULL;
    335  	    remainder->bk_nextsize = NULL;
      .  	  }
      .  
  4,808  	set_head(victim, nb | PREV_INUSE |
      .  		 (av != &main_arena ? NON_MAIN_ARENA : 0));
  1,803  	set_head(remainder, remainder_size | PREV_INUSE);
    601  	set_foot(remainder, remainder_size);
      .  
      .  	check_malloced_chunk(av, victim, nb);
    601  	void *p = chunk2mem(victim);
  1,803  	if (__builtin_expect (perturb_byte, 0))
      .  	  alloc_perturb (p, bytes);
      .  	return p;
      .        }
      .  
      .        /* remove from unsorted list */
    637        unsorted_chunks(av)->bk = bck;
    637        bck->fd = unsorted_chunks(av);
      .  
      .        /* Take now instead of binning if exact fit */
      .  
  1,274        if (size == nb) {
     41  	set_inuse_bit_at_offset(victim, size);
    123  	if (av != &main_arena)
      .  	  victim->size |= NON_MAIN_ARENA;
      .  	check_malloced_chunk(av, victim, nb);
      .  	void *p = chunk2mem(victim);
      .  	if (__builtin_expect (perturb_byte, 0))
      .  	  alloc_perturb (p, bytes);
      .  	return p;
      .        }
      .  
      .        /* place chunk in bin */
      .  
  1,192        if (in_smallbin_range(size)) {
    736  	victim_index = smallbin_index(size);
  1,104  	bck = bin_at(av, victim_index);
    368  	fwd = bck->fd;
      .        }
      .        else {
  2,582  	victim_index = largebin_index(size);
    228  	bck = bin_at(av, victim_index);
    228  	fwd = bck->fd;
      .  
      .  	/* maintain large bins in sorted order */
    456  	if (fwd != bck) {
      .  	  /* Or with inuse bit to speed comparisons */
     11  	  size |= PREV_INUSE;
      .  	  /* if smaller than smallest, bypass loop below */
     44  	  assert((bck->bk->size & NON_MAIN_ARENA) == 0);
     22  	  if ((unsigned long)(size) < (unsigned long)(bck->bk->size)) {
      .  	    fwd = bck;
      .  	    bck = bck->bk;
      .  
      1  	    victim->fd_nextsize = fwd->fd;
      2  	    victim->bk_nextsize = fwd->fd->bk_nextsize;
      4  	    fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;
      .  	  }
      .  	  else {
     30  	    assert((fwd->size & NON_MAIN_ARENA) == 0);
     20  	    while ((unsigned long) size < fwd->size)
      .  	      {
      .  		fwd = fwd->fd_nextsize;
      .  		assert((fwd->size & NON_MAIN_ARENA) == 0);
      .  	      }
      .  
     10  	    if ((unsigned long) size == (unsigned long) fwd->size)
      .  	      /* Always insert in the second position.  */
     18  	      fwd = fwd->fd;
      .  	    else
      .  	      {
      1  		victim->fd_nextsize = fwd;
      2  		victim->bk_nextsize = fwd->bk_nextsize;
      1  		fwd->bk_nextsize = victim;
      2  		victim->bk_nextsize->fd_nextsize = victim;
      .  	      }
     20  	    bck = fwd->bk;
      .  	  }
      .  	} else
    868  	  victim->fd_nextsize = victim->bk_nextsize = victim;
      .        }
      .  
  6,580        mark_bin(av, victim_index);
    596        victim->bk = bck;
    596        victim->fd = fwd;
    596        fwd->bk = victim;
    596        bck->fd = victim;
      .  
      .  #define MAX_ITERS	10000
  1,192        if (++iters >= MAX_ITERS)
      .  	break;
      .      }
      .  
      .      /*
      .        If a large request, scan through the chunks of current bin in
      .        sorted order to find smallest that fits.  Use the skip list for this.
      .      */
      .  
  4,724      if (!in_smallbin_range(nb)) {
    162        bin = bin_at(av, idx);
      .  
      .        /* skip scan if empty or largest chunk is too small */
    247        if ((victim = first(bin)) != bin &&
      .  	  (unsigned long)(victim->size) >= (unsigned long)(nb)) {
      .  
      2  	victim = victim->bk_nextsize;
      5  	while (((unsigned long)(size = chunksize(victim)) <
      .  		(unsigned long)(nb)))
      .  	  victim = victim->bk_nextsize;
      .  
      .  	/* Avoid removing the first entry for a size so that the skip
      .  	   list does not have to be rerouted.  */
      3  	if (victim != last(bin) && victim->size == victim->fd->size)
      .  	  victim = victim->fd;
      .  
      2  	remainder_size = size - nb;
     23  	unlink(av, victim, bck, fwd);
      .  
      .  	/* Exhaust */
      2  	if (remainder_size < MINSIZE)  {
      .  	  set_inuse_bit_at_offset(victim, size);
      .  	  if (av != &main_arena)
      .  	    victim->size |= NON_MAIN_ARENA;
      .  	}
      .  	/* Split */
      .  	else {
      1  	  remainder = chunk_at_offset(victim, nb);
      .  	  /* We cannot assume the unsorted list is empty and therefore
      .  	     have to perform a complete insert here.  */
      .  	  bck = unsorted_chunks(av);
      1  	  fwd = bck->fd;
      2  	  if (__builtin_expect (fwd->bk != bck, 0))
      .  	    {
      .  	      errstr = "malloc(): corrupted unsorted chunks";
      .  	      goto errout;
      .  	    }
      1  	  remainder->bk = bck;
      1  	  remainder->fd = fwd;
      1  	  bck->fd = remainder;
      1  	  fwd->bk = remainder;
      2  	  if (!in_smallbin_range(remainder_size))
      .  	    {
      .  	      remainder->fd_nextsize = NULL;
      .  	      remainder->bk_nextsize = NULL;
      .  	    }
      .  	  set_head(victim, nb | PREV_INUSE |
      .  		   (av != &main_arena ? NON_MAIN_ARENA : 0));
      .  	  set_head(remainder, remainder_size | PREV_INUSE);
      .  	  set_foot(remainder, remainder_size);
-- line 3739 ----------------------------------------
-- line 3752 ----------------------------------------
      .        (with ties going to approximately the least recently used) chunk
      .        that fits is selected.
      .  
      .        The bitmap avoids needing to check that most blocks are nonempty.
      .        The particular case of skipping all bins during warm-up phases
      .        when no chunks have been returned yet is faster than it might look.
      .      */
      .  
  2,361      ++idx;
  4,722      bin = bin_at(av,idx);
  4,722      block = idx2block(idx);
  7,083      map = av->binmap[block];
  7,083      bit = idx2bit(idx);
      .  
      .      for (;;) {
      .  
      .        /* Skip rest of block if there are no more set bits in this block.  */
 12,561        if (bit > map || bit == 0) {
      .  	do {
 24,366  	  if (++block >= BINMAPSIZE)  /* out of bins */
      .  	    goto use_top;
 24,680  	} while ( (map = av->binmap[block]) == 0);
      .  
    836  	bin = bin_at(av, (block << BINMAPSHIFT));
    209  	bit = 1;
      .        }
      .  
      .        /* Advance to bin with set bit. There must be one. */
  7,142        while ((bit & map) == 0) {
  2,819  	bin = next_bin(bin);
      .  	bit <<= 1;
  5,638  	assert(bit != 0);
      .        }
      .  
      .        /* Inspect the bin. It is likely to be non-empty */
    651        victim = last(bin);
      .  
      .        /*  If a false alarm (empty bin), clear the bit. */
  1,302        if (victim == bin) {
    968  	av->binmap[block] = map &= ~bit; /* Write through */
    242  	bin = next_bin(bin);
    242  	bit <<= 1;
      .        }
      .  
      .        else {
  1,227  	size = chunksize(victim);
      .  
      .  	/*  We know the first chunk in this bin is big enough to use. */
    818  	assert((unsigned long)(size) >= (unsigned long)(nb));
      .  
    818  	remainder_size = size - nb;
      .  
      .  	/* unlink */
  6,982  	unlink(av, victim, bck, fwd);
      .  
      .  	/* Exhaust */
    818  	if (remainder_size < MINSIZE) {
     54  	  set_inuse_bit_at_offset(victim, size);
    216  	  if (av != &main_arena)
      .  	    victim->size |= NON_MAIN_ARENA;
      .  	}
      .  
      .  	/* Split */
      .  	else {
    355  	  remainder = chunk_at_offset(victim, nb);
      .  
      .  	  /* We cannot assume the unsorted list is empty and therefore
      .  	     have to perform a complete insert here.  */
      .  	  bck = unsorted_chunks(av);
    355  	  fwd = bck->fd;
    710  	  if (__builtin_expect (fwd->bk != bck, 0))
      .  	    {
      .  	      errstr = "malloc(): corrupted unsorted chunks 2";
      .  	      goto errout;
      .  	    }
    355  	  remainder->bk = bck;
    355  	  remainder->fd = fwd;
    355  	  bck->fd = remainder;
    355  	  fwd->bk = remainder;
      .  
      .  	  /* advertise as last remainder */
    710  	  if (in_smallbin_range(nb))
    319  	    av->last_remainder = remainder;
    710  	  if (!in_smallbin_range(remainder_size))
      .  	    {
    181  	      remainder->fd_nextsize = NULL;
    181  	      remainder->bk_nextsize = NULL;
      .  	    }
  2,848  	  set_head(victim, nb | PREV_INUSE |
      .  		   (av != &main_arena ? NON_MAIN_ARENA : 0));
  1,068  	  set_head(remainder, remainder_size | PREV_INUSE);
    712  	  set_foot(remainder, remainder_size);
      .  	}
      .  	check_malloced_chunk(av, victim, nb);
      .  	void *p = chunk2mem(victim);
      .  	if (__builtin_expect (perturb_byte, 0))
      .  	  alloc_perturb (p, bytes);
      .  	return p;
      .        }
    242      }
      .  
      .    use_top:
      .      /*
      .        If large enough, split off the chunk bordering the end of memory
      .        (held in av->top). Note that this is in accord with the best-fit
      .        search rule.  In effect, av->top is treated as larger (and thus
      .        less well fitting) than any other available chunk since it can
      .        be extended to be as large as necessary (up to system
-- line 3859 ----------------------------------------
-- line 3861 ----------------------------------------
      .  
      .        We require that av->top always exists (i.e., has size >=
      .        MINSIZE) after initialization, so if it would otherwise be
      .        exhausted by current request, it is replenished. (The main
      .        reason for ensuring it exists is that we may need MINSIZE space
      .        to put in fenceposts in sysmalloc.)
      .      */
      .  
  1,952      victim = av->top;
  5,856      size = chunksize(victim);
      .  
  3,904      if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
  1,945        remainder_size = size - nb;
  1,945        remainder = chunk_at_offset(victim, nb);
  1,945        av->top = remainder;
 15,560        set_head(victim, nb | PREV_INUSE |
      .  	       (av != &main_arena ? NON_MAIN_ARENA : 0));
  5,835        set_head(remainder, remainder_size | PREV_INUSE);
      .  
      .        check_malloced_chunk(av, victim, nb);
 91,591        void *p = chunk2mem(victim);
274,773        if (__builtin_expect (perturb_byte, 0))
      .  	alloc_perturb (p, bytes);
      .        return p;
      .      }
      .  
      .      /* When we are using atomic ops to free fast chunks we can get
      .         here for all block sizes.  */
     21      else if (have_fastchunks(av)) {
      .        malloc_consolidate(av);
      .        /* restore original bin index */
      .        if (in_smallbin_range(nb))
  9,012  	idx = smallbin_index(nb);
      .        else
 75,100  	idx = largebin_index(nb);
      .      }
      .  
      .      /*
      .         Otherwise, relay to handle system-dependent cases
      .      */
      .      else {
      .        void *p = sYSMALLOc(nb, av);
     56        if (p != NULL && __builtin_expect (perturb_byte, 0))
      1  	alloc_perturb (p, bytes);
      .        return p;
      .      }
      .    }
829,791  }
      .  
      .  /*
      .    ------------------------------ free ------------------------------
      .  */
      .  
      .  static void
      .  _int_free(mstate av, mchunkptr p, int have_lock)
917,130  {
      .    INTERNAL_SIZE_T size;        /* its size */
      .    mfastbinptr*    fb;          /* associated fastbin */
      .    mchunkptr       nextchunk;   /* next contiguous chunk */
      .    INTERNAL_SIZE_T nextsize;    /* its size */
      .    int             nextinuse;   /* true if nextchunk is used */
      .    INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */
      .    mchunkptr       bck;         /* misc temp for linking */
      .    mchunkptr       fwd;         /* misc temp for linking */
      .  
      .    const char *errstr = NULL;
    709    int locked = 0;
      .  
275,139    size = chunksize(p);
      .  
      .    /* Little security check which won't hurt performance: the
      .       allocator never wrapps around at the end of the address space.
      .       Therefore we can exclude some size values which might appear
      .       here by accident or by "design" from some intruder.  */
366,852    if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
183,426        || __builtin_expect (misaligned_chunk (p), 0))
      .      {
      .        errstr = "free(): invalid pointer";
      .      errout:
      .        if (have_lock || locked)
      .  	(void)mutex_unlock(&av->mutex);
      .        malloc_printerr (check_action, errstr, chunk2mem(p));
      .        if (have_lock)
      .  	mutex_lock(&av->mutex);
      .        return;
      .      }
      .    /* We know that each chunk is at least MINSIZE bytes in size.  */
183,426    if (__builtin_expect (size < MINSIZE, 0))
      .      {
      .        errstr = "free(): invalid size";
      .        goto errout;
      .      }
      .  
      .    check_inuse_chunk(av, p);
      .  
      .    /*
      .      If eligible, place chunk on a fastbin so it can be found
      .      and used quickly in malloc.
      .    */
      .  
183,426    if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())
      .  
      .  #if TRIM_FASTBINS
      .        /*
      .  	If TRIM_FASTBINS set, don't place chunks
      .  	bordering top into fastbins
      .        */
      .        && (chunk_at_offset(p, size) != av->top)
      .  #endif
      .        ) {
      .  
364,016      if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)
273,012  	|| __builtin_expect (chunksize (chunk_at_offset (p, size))
      .  			     >= av->system_mem, 0))
      .        {
      .  	/* We might not have a lock at this point and concurrent modifications
      .  	   of system_mem might have let to a false positive.  Redo the test
      .  	   after getting the lock.  */
      .  	if (have_lock
      .  	    || ({ assert (locked == 0);
      .  		  mutex_lock(&av->mutex);
-- line 3981 ----------------------------------------
-- line 3989 ----------------------------------------
      .  	  }
      .  	if (! have_lock)
      .  	  {
      .  	    (void)mutex_unlock(&av->mutex);
      .  	    locked = 0;
      .  	  }
      .        }
      .  
273,012      if (__builtin_expect (perturb_byte, 0))
      .        free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
      .  
273,012      set_fastchunks(av);
182,008      unsigned int idx = fastbin_index(size);
182,008      fb = &fastbin (av, idx);
      .  
      .      mchunkptr fd;
 91,004      mchunkptr old = *fb;
182,008      unsigned int old_idx = ~0u;
      .      do
      .        {
      .  	/* Another simple check: make sure the top of the bin is not the
      .  	   record we are going to add (i.e., double free).  */
182,008  	if (__builtin_expect (old == p, 0))
      .  	  {
      .  	    errstr = "double free or corruption (fasttop)";
      .  	    goto errout;
      .  	  }
182,008  	if (old != NULL)
239,625  	  old_idx = fastbin_index(chunksize(old));
 91,004  	p->fd = fd = old;
      .        }
546,024      while ((old = catomic_compare_and_exchange_val_rel (fb, p, fd)) != fd);
      .  
341,758      if (fd != NULL && __builtin_expect (old_idx != idx, 0))
      .        {
      .  	errstr = "invalid fastbin entry (free)";
      .  	goto errout;
      .        }
      .    }
      .  
      .    /*
      .      Consolidate other non-mmapped chunks as they arrive.
      .    */
      .  
  1,418    else if (!chunk_is_mmapped(p)) {
  2,127      if (! have_lock) {
      .  #if THREAD_STATS
      .        if(!mutex_trylock(&av->mutex))
      .  	++(av->stat_lock_direct);
      .        else {
      .  	(void)mutex_lock(&av->mutex);
      .  	++(av->stat_lock_wait);
      .        }
      .  #else
  4,092        (void)mutex_lock(&av->mutex);
      .  #endif
  1,364        locked = 1;
      .      }
      .  
    709      nextchunk = chunk_at_offset(p, size);
      .  
      .      /* Lightweight tests: check whether the block is already the
      .         top block.  */
  2,127      if (__builtin_expect (p == av->top, 0))
      .        {
      .  	errstr = "double free or corruption (top)";
      .  	goto errout;
      .        }
      .      /* Or whether the next chunk is beyond the boundaries of the arena.  */
  2,836      if (__builtin_expect (contiguous (av)
      .  			  && (char *) nextchunk
  2,127  			  >= ((char *) av->top + chunksize(av->top)), 0))
      .        {
      .  	errstr = "double free or corruption (out)";
      .  	goto errout;
      .        }
      .      /* Or whether the block is actually not marked used.  */
  2,127      if (__builtin_expect (!prev_inuse(nextchunk), 0))
      .        {
      .  	errstr = "double free or corruption (!prev)";
      .  	goto errout;
      .        }
      .  
    709      nextsize = chunksize(nextchunk);
  1,418      if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)
  1,418  	|| __builtin_expect (nextsize >= av->system_mem, 0))
      .        {
      .  	errstr = "free(): invalid next size (normal)";
      .  	goto errout;
      .        }
      .  
  2,127      if (__builtin_expect (perturb_byte, 0))
      .        free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
      .  
      .      /* consolidate backward */
  1,418      if (!prev_inuse(p)) {
     58        prevsize = p->prev_size;
     58        size += prevsize;
     58        p = chunk_at_offset(p, -((long) prevsize));
    776        unlink(av, p, bck, fwd);
      .      }
      .  
  1,418      if (nextchunk != av->top) {
      .        /* get and clear inuse bit */
      .        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
      .  
      .        /* consolidate forward */
    882        if (!nextinuse) {
  2,883  	unlink(av, nextchunk, bck, fwd);
    226  	size += nextsize;
      .        } else
    430  	clear_inuse_bit_at_offset(nextchunk, 0);
      .  
      .        /*
      .  	Place the chunk in unsorted chunk list. Chunks are
      .  	not placed into regular bins until after they have
      .  	been given one chance to be used in malloc.
      .        */
      .  
    441        bck = unsorted_chunks(av);
    441        fwd = bck->fd;
    882        if (__builtin_expect (fwd->bk != bck, 0))
      .  	{
      .  	  errstr = "free(): corrupted unsorted chunks";
      .  	  goto errout;
      .  	}
    441        p->fd = fwd;
    441        p->bk = bck;
    882        if (!in_smallbin_range(size))
      .  	{
    245  	  p->fd_nextsize = NULL;
    245  	  p->bk_nextsize = NULL;
      .  	}
    441        bck->fd = p;
    441        fwd->bk = p;
      .  
  1,323        set_head(p, size | PREV_INUSE);
    441        set_foot(p, size);
      .  
      .        check_free_chunk(av, p);
      .      }
      .  
      .      /*
      .        If the chunk borders the current high end of memory,
      .        consolidate into top
      .      */
      .  
      .      else {
    268        size += nextsize;
    804        set_head(p, size | PREV_INUSE);
    536        av->top = p;
      .        check_chunk(av, p);
      .      }
      .  
      .      /*
      .        If freeing a large space, consolidate possibly-surrounding
      .        chunks. Then, if the total unused topmost memory exceeds trim
      .        threshold, ask malloc_trim to reduce top.
      .  
-- line 4147 ----------------------------------------
-- line 4148 ----------------------------------------
      .        Unless max_fast is 0, we don't know if there are fastbins
      .        bordering top, so we cannot tell for sure whether threshold
      .        has been reached unless fastbins are consolidated.  But we
      .        don't want to consolidate on each free.  As a compromise,
      .        consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
      .        is reached.
      .      */
      .  
  1,418      if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
  1,048        if (have_fastchunks(av))
      .  	malloc_consolidate(av);
      .  
    524        if (av == &main_arena) {
      .  #ifndef MORECORE_CANNOT_TRIM
  1,310  	if ((unsigned long)(chunksize(av->top)) >=
      .  	    (unsigned long)(mp_.trim_threshold))
     10  	  sYSTRIm(mp_.top_pad, av);
    442  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:sYSTRIm.isra.1 (2x)
      .  #endif
      .        } else {
      .  	/* Always try heap_trim(), even if the top chunk is not
      .  	   large, because the corresponding heap might go away.  */
      .  	heap_info *heap = heap_for_ptr(top(av));
      .  
      .  	assert(heap->ar_ptr == av);
      .  	heap_trim(heap, mp_.top_pad);
      .        }
      .      }
      .  
  2,127      if (! have_lock) {
  2,046        assert (locked);
  2,728        (void)mutex_unlock(&av->mutex);
      .      }
      .    }
      .    /*
      .      If the chunk was allocated via mmap, release via munmap().
      .    */
      .  
      .    else {
      .      munmap_chunk (p);
      .    }
733,704  }
      .  
      .  /*
      .    ------------------------- malloc_consolidate -------------------------
      .  
      .    malloc_consolidate is a specialized version of free() that tears
      .    down chunks held in fastbins.  Free itself cannot be used for this
      .    purpose since, among other things, it might place chunks back onto
      .    fastbins.  So, instead, we need to use a minor variant of the same
      .    code.
      .  
      .    Also, because this routine needs to be called the first time through
      .    malloc anyway, it turns out to be the perfect place to trigger
      .    initialization code.
      .  */
      .  
  1,026  static void malloc_consolidate(mstate av)
      .  {
      .    mfastbinptr*    fb;                 /* current fastbin being consolidated */
      .    mfastbinptr*    maxfb;              /* last fastbin (for loop control) */
      .    mchunkptr       p;                  /* current chunk being consolidated */
      .    mchunkptr       nextp;              /* next chunk to consolidate */
      .    mchunkptr       unsorted_bin;       /* bin header */
      .    mchunkptr       first_unsorted;     /* chunk to link to */
      .  
-- line 4212 ----------------------------------------
-- line 4219 ----------------------------------------
      .    mchunkptr       bck;
      .    mchunkptr       fwd;
      .  
      .    /*
      .      If max_fast is 0, we know that av hasn't
      .      yet been initialized, in which case do so below
      .    */
      .  
    510    if (get_max_fast () != 0) {
 25,241  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc_consolidate.part.3 (2x)
    171      clear_fastchunks(av);
      .  
     57      unsorted_bin = unsorted_chunks(av);
      .  
      .      /*
      .        Remove each chunk from fast bin and consolidate it, placing it
      .        then in unsorted bin. Among other reasons for doing this,
      .        placing in unsorted bin avoids needing to calculate actual bins
      .        until malloc is sure that chunks aren't immediately going to be
      .        reused anyway.
      .      */
      .  
     57      maxfb = &fastbin (av, NFASTBINS - 1);
    114      fb = &fastbin (av, 0);
      .      do {
  1,140        p = atomic_exchange_acq (fb, 0);
  1,580        if (p != 0) {
      .  	do {
      .  	  check_inuse_chunk(av, p);
  1,836  	  nextp = p->fd;
      .  
      .  	  /* Slightly streamlined version of consolidation code in free() */
  5,508  	  size = p->size & ~(PREV_INUSE|NON_MAIN_ARENA);
  1,836  	  nextchunk = chunk_at_offset(p, size);
  3,672  	  nextsize = chunksize(nextchunk);
      .  
  3,672  	  if (!prev_inuse(p)) {
    917  	    prevsize = p->prev_size;
    917  	    size += prevsize;
    917  	    p = chunk_at_offset(p, -((long) prevsize));
  9,597  	    unlink(av, p, bck, fwd);
      .  	  }
      .  
  3,672  	  if (nextchunk != av->top) {
      .  	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
      .  
  3,632  	    if (!nextinuse) {
    844  	      size += nextsize;
  8,865  	      unlink(av, nextchunk, bck, fwd);
      .  	    } else
  1,944  	      clear_inuse_bit_at_offset(nextchunk, 0);
      .  
  1,816  	    first_unsorted = unsorted_bin->fd;
  1,816  	    unsorted_bin->fd = p;
  1,816  	    first_unsorted->bk = p;
      .  
  3,632  	    if (!in_smallbin_range (size)) {
    271  	      p->fd_nextsize = NULL;
    271  	      p->bk_nextsize = NULL;
      .  	    }
      .  
  5,448  	    set_head(p, size | PREV_INUSE);
  1,816  	    p->bk = unsorted_bin;
  1,816  	    p->fd = first_unsorted;
  1,816  	    set_foot(p, size);
      .  	  }
      .  
      .  	  else {
     20  	    size += nextsize;
     40  	    set_head(p, size | PREV_INUSE);
     40  	    av->top = p;
      .  	  }
      .  
  5,378  	} while ( (p = nextp) != 0);
      .  
      .        }
  1,710      } while (fb++ != maxfb);
      .    }
      .    else {
      .      malloc_init_state(av);
      .      check_malloc_state(av);
      .    }
    456  }
      .  
      .  /*
      .    ------------------------------ realloc ------------------------------
      .  */
      .  
      .  void*
      .  _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,
      .  	     INTERNAL_SIZE_T nb)
  1,215  {
      .    mchunkptr        newp;            /* chunk to return */
      .    INTERNAL_SIZE_T  newsize;         /* its size */
      .    void*          newmem;          /* corresponding user mem */
      .  
      .    mchunkptr        next;            /* next contiguous chunk after oldp */
      .  
      .    mchunkptr        remainder;       /* extra space at end of newp */
      .    unsigned long    remainder_size;  /* its size */
-- line 4317 ----------------------------------------
-- line 4322 ----------------------------------------
      .    unsigned long    copysize;        /* bytes to copy */
      .    unsigned int     ncopies;         /* INTERNAL_SIZE_T words to copy */
      .    INTERNAL_SIZE_T* s;               /* copy source */
      .    INTERNAL_SIZE_T* d;               /* copy destination */
      .  
      .    const char *errstr = NULL;
      .  
      .    /* oldmem size */
    405    if (__builtin_expect (oldp->size <= 2 * SIZE_SZ, 0)
    405        || __builtin_expect (oldsize >= av->system_mem, 0))
      .      {
      .        errstr = "realloc(): invalid old size";
      .      errout:
      .        mutex_unlock(&av->mutex);
      .        malloc_printerr (check_action, errstr, chunk2mem(oldp));
      .        mutex_lock(&av->mutex);
      .        return NULL;
      .      }
      .  
      .    check_inuse_chunk(av, oldp);
      .  
      .    /* All callers already filter out mmap'ed chunks.  */
    270    assert (!chunk_is_mmapped(oldp));
      .  
    135    next = chunk_at_offset(oldp, oldsize);
    405    INTERNAL_SIZE_T nextsize = chunksize(next);
    270    if (__builtin_expect (next->size <= 2 * SIZE_SZ, 0)
    270        || __builtin_expect (nextsize >= av->system_mem, 0))
      .      {
      .        errstr = "realloc(): invalid next size";
      .        goto errout;
      .      }
      .  
    405    if ((unsigned long)(oldsize) >= (unsigned long)(nb)) {
      .      /* already big enough; split below */
      .      newp = oldp;
      .      newsize = oldsize;
      .    }
      .  
      .    else {
      .      /* Try to expand forward into top */
    122      if (next == av->top &&
     10  	(unsigned long)(newsize = oldsize + nextsize) >=
     10  	(unsigned long)(nb + MINSIZE)) {
     72        set_head_size(oldp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
     16        av->top = chunk_at_offset(oldp, nb);
     24        set_head(av->top, (newsize - nb) | PREV_INUSE);
      .        check_inuse_chunk(av, oldp);
     16        return chunk2mem(oldp);
      .      }
      .  
      .      /* Try to expand forward into next chunk;  split off remainder below */
     82      else if (next != av->top &&
     24  	     !inuse(next) &&
     12  	     (unsigned long)(newsize = oldsize + nextsize) >=
      .  	     (unsigned long)(nb)) {
      .        newp = oldp;
    192        unlink(av, next, bck, fwd);
      .      }
      .  
      .      /* allocate, copy, free */
      .      else {
    175        newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK);
 11,210  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_malloc (35x)
    105        if (newmem == 0)
      .  	return 0; /* propagate failure */
      .  
     35        newp = mem2chunk(newmem);
     36        newsize = chunksize(newp);
      .  
      .        /*
      .  	Avoid copy if newp is next chunk after oldp.
      .        */
     70        if (newp == next) {
      1  	newsize += oldsize;
      .  	newp = oldp;
      .        }
      .        else {
      .  	/*
      .  	  Unroll copy of <= 36 bytes (72 if 8byte sizes)
      .  	  We know that contents have an odd number of
      .  	  INTERNAL_SIZE_T-sized words; minimally 3.
      .  	*/
      .  
     34  	copysize = oldsize - SIZE_SZ;
     21  	s = (INTERNAL_SIZE_T*)(chunk2mem(oldp));
      .  	d = (INTERNAL_SIZE_T*)(newmem);
     68  	ncopies = copysize / sizeof(INTERNAL_SIZE_T);
     68  	assert(ncopies >= 3);
      .  
     68  	if (ncopies > 9)
     63  	  MALLOC_COPY(d, s, copysize);
 72,810  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/string/../sysdeps/x86_64/memcpy.S:__GI_memcpy (21x)
      .  
      .  	else {
     26  	  *(d+0) = *(s+0);
     26  	  *(d+1) = *(s+1);
     26  	  *(d+2) = *(s+2);
     26  	  if (ncopies > 4) {
     10  	    *(d+3) = *(s+3);
     10  	    *(d+4) = *(s+4);
     10  	    if (ncopies > 6) {
      4  	      *(d+5) = *(s+5);
      4  	      *(d+6) = *(s+6);
      4  	      if (ncopies > 8) {
      2  		*(d+7) = *(s+7);
      2  		*(d+8) = *(s+8);
      .  	      }
      .  	    }
      .  	  }
      .  	}
      .  
    136  	_int_free(av, oldp, 1);
  3,135  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_free (34x)
      .  	check_inuse_chunk(av, newp);
     34  	return chunk2mem(newp);
      .        }
      .      }
      .    }
      .  
      .    /* If possible, free extra space in old or extended chunk */
      .  
      4    assert((unsigned long)(newsize) >= (unsigned long)(nb));
      .  
    186    remainder_size = newsize - nb;
      .  
    186    if (remainder_size < MINSIZE) { /* not enough extra to split off */
    270      set_head_size(newp, newsize | (av != &main_arena ? NON_MAIN_ARENA : 0));
     60      set_inuse_bit_at_offset(newp, newsize);
      .    }
      .    else { /* split remainder */
     63      remainder = chunk_at_offset(newp, nb);
    441      set_head_size(newp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
    315      set_head(remainder, remainder_size | PREV_INUSE |
      .  	     (av != &main_arena ? NON_MAIN_ARENA : 0));
      .      /* Mark remainder as inuse so free() won't complain */
     63      set_inuse_bit_at_offset(remainder, remainder_size);
    189      _int_free(av, remainder, 1);
  4,717  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:_int_free (63x)
      .    }
      .  
      .    check_inuse_chunk(av, newp);
     93    return chunk2mem(newp);
  1,080  }
      .  
      .  /*
      .    ------------------------------ memalign ------------------------------
      .  */
      .  
      .  static void*
      .  _int_memalign(mstate av, size_t alignment, size_t bytes)
      .  {
-- line 4469 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.14-394-g8f3b1ff/libio/getc.c
--------------------------------------------------------------------------------
       Ir 

-- line 29 ----------------------------------------
        .  #include "libioP.h"
        .  #include "stdio.h"
        .  
        .  #undef _IO_getc
        .  
        .  int
        .  _IO_getc (fp)
        .       FILE *fp;
1,021,166  {
        .    int result;
        .    CHECK_FILE (fp, EOF);
7,658,745    _IO_acquire_lock (fp);
3,063,624    result = _IO_getc_unlocked (fp);
   14,083  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/libio/genops.c:__uflow (126x)
        .    _IO_release_lock (fp);
        .    return result;
1,531,749  }
        .  
        .  #undef getc
        .  
        .  #ifdef weak_alias
        .  weak_alias (_IO_getc, getc)
        .  weak_alias (_IO_getc, fgetc)
        .  
        .  #ifndef _IO_MTSAFE_IO
-- line 52 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: src/main.cpp
--------------------------------------------------------------------------------
       Ir 

-- line 7 ----------------------------------------
        .  
        .  #define WIDTH 1280
        .  #define HEIGHT 720
        .  
        .  #define CAM_TRANS_FACTOR  5
        .  #define CAM_ROT_ANGLE     2
        .  
        .  int main(int argc, char* argv[])
        9  {
        2      string filename;
      106  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
        .      int frameNumber = 0;
        .  
        8      Logger::init("pray_client.log");
    3,599  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
   39,362  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::init(std::string) (1x)
    2,826  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (2x)
   67,670  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.tcc:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
        .  
        2      if (argc != 2) {
        .          Logger::log(LOG_ERROR) << "Missing argument" << endl;
        .          Logger::log(LOG_INFO) << "Usage: " << argv[0] << " scene.xml" << endl;
        .  	return EXIT_FAILURE;
        .      } 
        .      
        7      filename = string(argv[1]);
        7  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
      329  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.tcc:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
        .  
        7      const string standaloneMode ("--test");
      106  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
      225  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.tcc:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (1x)
        .  
        .      if (true) // if (argc > 0 && standaloneMode.compare(argv[0]) == 0)
        .      {
        3          Display::init(WIDTH,HEIGHT);
75,284,172  => /home/guillaume/dev/pray/common/src/display.cpp:Display::init(int, int) (1x)
        2          Display *disp = &(Display::getInstance());
        2  => /home/guillaume/dev/pray/common/src/display.cpp:Display::getInstance() (1x)
        .          
        3          Color pixel;
        4  => /home/guillaume/dev/pray/common/src/color.cpp:Color::Color(float) (1x)
        3          int width = disp->get_width();
        2  => /home/guillaume/dev/pray/common/src/display.cpp:Display::get_width() (1x)
        3          int height = disp->get_height();
        2  => /home/guillaume/dev/pray/common/src/display.cpp:Display::get_height() (1x)
        .  
        .          SceneLoader sceneLoader;
        .          Scene* scene;
        .  	
       14  	if ( sceneLoader.load(filename, &scene, width, height) != 0 ) {
       18  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.h:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() (1x)
1,122,311  => /home/guillaume/dev/pray/client/src/sceneLoader.cpp:SceneLoader::load(std::string, Scene**, int, int) (1x)
       18  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/basic_string.tcc:std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (1x)
        1  	    return EXIT_FAILURE;
        .  	}
        .  
       14          Logger::log(LOG_INFO)<<"Rendering started in "<<width<<"x"<<height<<endl;
    1,824  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/ostream:std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*) (2x)
      598  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/ostream.tcc:std::ostream::operator<<(int) (2x)
    2,061  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
      451  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::log(Log_Type) (1x)
        .  
        9          disp->register_keyhook(std::bind(&Camera::translateForward,   scene->getCamera()), SDLK_z);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      349  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::translateBackwards, scene->getCamera()), SDLK_s);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
    3,843  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::translateRight,     scene->getCamera()), SDLK_d);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      689  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::translateLeft,      scene->getCamera()), SDLK_q);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::translateUp,        scene->getCamera()), SDLK_r);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      801  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::translateDown,      scene->getCamera()), SDLK_f);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::rollLeft,           scene->getCamera()), SDLK_a);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::rollRight,          scene->getCamera()), SDLK_e);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::pitchUp,            scene->getCamera()), SDLK_UP);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
    1,053  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::pitchDown,          scene->getCamera()), SDLK_DOWN);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::yawLeft,            scene->getCamera()), SDLK_LEFT);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::yawRight,           scene->getCamera()), SDLK_RIGHT);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::switchMode,         scene->getCamera()), SDLK_m);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        9          disp->register_keyhook(std::bind(&Camera::logInformations,    scene->getCamera()), SDLK_c);
      136  => /usr/lib/gcc/x86_64-redhat-linux/4.6.2/../../../../include/c++/4.6.2/functional:_ZNSt8functionIFvvEEC2ISt5_BindIFSt7_Mem_fnIM6CameraFvvEEPS5_EEEET_NSt9enable_ifIXntsrSt11is_integralISC_E5valueENS1_8_UselessEE4typeE.isra.28.constprop.31 (1x)
      201  => /home/guillaume/dev/pray/common/src/display.cpp:Display::register_keyhook(std::function<void ()()>, SDLKey) (1x)
        2  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::getCamera() (1x)
        .  
        8          while ( !disp->quit() )
        4  => /home/guillaume/dev/pray/common/src/display.cpp:Display::quit() (2x)
        .          {
    2,165              for (int y=0 ; y < height ; y++)
        .              {
2,767,680                  for (int x=0 ; x < width ; x++)
        .                  {
8,294,400                      pixel = scene->renderPixel(x,y);
2,390,396,213  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::renderPixel(int, int) (921600x)
        .  
4,608,000                      disp->add_pixel(x,y,pixel);
70,042,285  => /home/guillaume/dev/pray/common/src/display.cpp:Display::add_pixel(int, int, Color) (921600x)
        .                  }
        .              }
        .  
        2              disp->refresh_display();
   14,974  => /home/guillaume/dev/pray/common/src/display.cpp:Display::refresh_display() (1x)
        .  
       13  	    Logger::log(LOG_INFO) << "Frame " << frameNumber++ << " rendered" << endl;
      271  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/bits/ostream.tcc:std::ostream::operator<<(int) (1x)
      453  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::log(Log_Type) (1x)
        .  
        2              disp->refresh_controls();
  783,571  => /home/guillaume/dev/pray/common/src/display.cpp:Display::refresh_controls() (1x)
        .  
        .          }
        .  
        5          Logger::log(LOG_INFO)<<"Rendering terminated"<<endl;
      169  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/include/ostream:std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*) (1x)
      453  => /home/guillaume/dev/pray/common/src/logger.cpp:Logger::log(Log_Type) (1x)
        .  
        7  	delete scene;
       87  => /usr/src/debug/gcc-4.6.2-20111027/obj-x86_64-redhat-linux/x86_64-redhat-linux/libstdc++-v3/libsupc++/../../../../libstdc++-v3/libsupc++/del_op.cc:operator delete(void*) (1x)
    2,385  => /home/guillaume/dev/pray/client/src/scene.cpp:Scene::~Scene() (1x)
        .      }
        .  
        1      return EXIT_SUCCESS;
       27  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/SDL-1.2.14/src/video/SDL_surface.c
--------------------------------------------------------------------------------
       Ir 

-- line 32 ----------------------------------------
        .  
        .  /* Public routines */
        .  /*
        .   * Create an empty RGB surface of the appropriate depth
        .   */
        .  SDL_Surface * SDL_CreateRGBSurface (Uint32 flags,
        .  			int width, int height, int depth,
        .  			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
       26  {
        4  	SDL_VideoDevice *video = current_video;
        .  	SDL_VideoDevice *this  = current_video;
        .  	SDL_Surface *screen;
        .  	SDL_Surface *surface;
        .  
        .  	/* Make sure the size requested doesn't overflow our datatypes */
        .  	/* Next time I write a library like SDL, I'll use int for size. :) */
        8  	if ( width >= 16384 || height >= 65536 ) {
        .  		SDL_SetError("Width or height is too large");
        .  		return(NULL);
        .  	}
        .  
        .  	/* Check to see if we desire the surface in video memory */
        4  	if ( video ) {
        2  		screen = SDL_PublicSurface;
        .  	} else {
        .  		screen = NULL;
        .  	}
        6  	if ( screen && ((screen->flags&SDL_HWSURFACE) == SDL_HWSURFACE) ) {
        .  		if ( (flags&(SDL_SRCCOLORKEY|SDL_SRCALPHA)) != 0 ) {
        .  			flags |= SDL_HWSURFACE;
        .  		}
        .  		if ( (flags & SDL_SRCCOLORKEY) == SDL_SRCCOLORKEY ) {
        .  			if ( ! current_video->info.blit_hw_CC ) {
        .  				flags &= ~SDL_HWSURFACE;
        .  			}
        .  		}
        .  		if ( (flags & SDL_SRCALPHA) == SDL_SRCALPHA ) {
        .  			if ( ! current_video->info.blit_hw_A ) {
        .  				flags &= ~SDL_HWSURFACE;
        .  			}
        .  		}
        .  	} else {
        2  		flags &= ~SDL_HWSURFACE;
        .  	}
        .  
        .  	/* Allocate the surface */
       14  	surface = (SDL_Surface *)SDL_malloc(sizeof(*surface));
      403  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc (2x)
       12  	if ( surface == NULL ) {
        .  		SDL_OutOfMemory();
        .  		return(NULL);
        .  	}
        2  	surface->flags = SDL_SWSURFACE;
        4  	if ( (flags & SDL_HWSURFACE) == SDL_HWSURFACE ) {
        .  		if ((Amask) && (video->displayformatalphapixel))
        .  		{
        .  			depth = video->displayformatalphapixel->BitsPerPixel;
        .  			Rmask = video->displayformatalphapixel->Rmask;
        .  			Gmask = video->displayformatalphapixel->Gmask;
        .  			Bmask = video->displayformatalphapixel->Bmask;
        .  			Amask = video->displayformatalphapixel->Amask;
        .  		}
-- line 92 ----------------------------------------
-- line 94 ----------------------------------------
        .  		{
        .  			depth = screen->format->BitsPerPixel;
        .  			Rmask = screen->format->Rmask;
        .  			Gmask = screen->format->Gmask;
        .  			Bmask = screen->format->Bmask;
        .  			Amask = screen->format->Amask;
        .  		}
        .  	}
       12  	surface->format = SDL_AllocFormat(depth, Rmask, Gmask, Bmask, Amask);
    1,095  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_AllocFormat (2x)
        4  	if ( surface->format == NULL ) {
        .  		SDL_free(surface);
        .  		return(NULL);
        .  	}
        4  	if ( Amask ) {
        .  		surface->flags |= SDL_SRCALPHA;
        .  	}
        2  	surface->w = width;
        2  	surface->h = height;
        6  	surface->pitch = SDL_CalculatePitch(surface);
       22  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_CalculatePitch (2x)
        2  	surface->pixels = NULL;
        2  	surface->offset = 0;
        2  	surface->hwdata = NULL;
        2  	surface->locked = 0;
        2  	surface->map = NULL;
        2  	surface->unused1 = 0;
        6  	SDL_SetClipRect(surface, NULL);
      645  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
       30  => /usr/src/debug/SDL-1.2.14/src/video/SDL_surface.c:SDL_SetClipRect (2x)
        4  	SDL_FormatChanged(surface);
       28  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_FormatChanged (2x)
        .  
        .  	/* Get the pixels */
        4  	if ( ((flags&SDL_HWSURFACE) == SDL_SWSURFACE) || 
        .  				(video->AllocHWSurface(this, surface) < 0) ) {
        9  		if ( surface->w && surface->h ) {
        6  			surface->pixels = SDL_malloc(surface->h*surface->pitch);
   27,982  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:malloc (1x)
        2  			if ( surface->pixels == NULL ) {
        .  				SDL_FreeSurface(surface);
        .  				SDL_OutOfMemory();
        .  				return(NULL);
        .  			}
        .  			/* This is important for bitmaps */
        .  			SDL_memset(surface->pixels, 0, surface->h*surface->pitch);
        .  		}
        .  	}
        .  
        .  	/* Allocate an empty mapping */
        4  	surface->map = SDL_AllocBlitMap();
      611  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_AllocBlitMap (2x)
        4  	if ( surface->map == NULL ) {
        .  		SDL_FreeSurface(surface);
        .  		return(NULL);
        .  	}
        .  
        .  	/* The surface is ready to go */
        2  	surface->refcount = 1;
        .  #ifdef CHECK_LEAKS
        .  	++surfaces_allocated;
        .  #endif
        .  	return(surface);
       18  }
        .  /*
        .   * Create an RGB surface from an existing memory buffer
        .   */
        .  SDL_Surface * SDL_CreateRGBSurfaceFrom (void *pixels,
        .  			int width, int height, int depth, int pitch,
        .  			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)
        .  {
        .  	SDL_Surface *surface;
-- line 158 ----------------------------------------
-- line 365 ----------------------------------------
        .  /*
        .   * Set the clipping rectangle for a blittable surface
        .   */
        .  SDL_bool SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect)
        .  {
        .  	SDL_Rect full_rect;
        .  
        .  	/* Don't do anything if there's no surface to act on */
        8  	if ( ! surface ) {
        4  		return SDL_FALSE;
        .  	}
        .  
        .  	/* Set up the full surface rectangle */
        .  	full_rect.x = 0;
        .  	full_rect.y = 0;
        8  	full_rect.w = surface->w;
        8  	full_rect.h = surface->h;
        .  
        .  	/* Set the clipping rectangle */
        8  	if ( ! rect ) {
       16  		surface->clip_rect = full_rect;
        8  		return 1;
        .  	}
        .  	return SDL_IntersectRect(rect, &full_rect, &surface->clip_rect);
        .  }
        .  void SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect)
        .  {
        .  	if ( surface && rect ) {
        .  		*rect = surface->clip_rect;
        .  	}
-- line 394 ----------------------------------------
-- line 401 ----------------------------------------
        .   *
        .   * These parts are separated out and each used internally by this 
        .   * library in the optimimum places.  They are exported so that if
        .   * you know exactly what you are doing, you can optimize your code
        .   * by calling the one(s) you need.
        .   */
        .  int SDL_LowerBlit (SDL_Surface *src, SDL_Rect *srcrect,
        .  				SDL_Surface *dst, SDL_Rect *dstrect)
        9  {
        .  	SDL_blit do_blit;
        .  	SDL_Rect hw_srcrect;
        .  	SDL_Rect hw_dstrect;
        .  
        .  	/* Check to make sure the blit mapping is valid */
        3  	if ( (src->map->dst != dst) ||
        .               (src->map->dst->format_version != src->map->format_version) ) {
        6  		if ( SDL_MapSurface(src, dst) < 0 ) {
      208  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_MapSurface (1x)
        .  			return(-1);
        .  		}
        .  	}
        .  
        .  	/* Figure out which blitter to use */
        3  	if ( (src->flags & SDL_HWACCEL) == SDL_HWACCEL ) {
        .  		if ( src == SDL_VideoSurface ) {
        .  			hw_srcrect = *srcrect;
        .  			hw_srcrect.x += current_video->offset_x;
        .  			hw_srcrect.y += current_video->offset_y;
        .  			srcrect = &hw_srcrect;
        .  		}
        .  		if ( dst == SDL_VideoSurface ) {
        .  			hw_dstrect = *dstrect;
        .  			hw_dstrect.x += current_video->offset_x;
        .  			hw_dstrect.y += current_video->offset_y;
        .  			dstrect = &hw_dstrect;
        .  		}
        .  		do_blit = src->map->hw_blit;
        .  	} else {
        1  		do_blit = src->map->sw_blit;
        .  	}
        5  	return(do_blit(src, srcrect, dst, dstrect));
52,425,505  => /usr/src/debug/SDL-1.2.14/src/video/SDL_blit.c:SDL_SoftBlit (1x)
        6  }
        .  
        .  
        .  int SDL_UpperBlit (SDL_Surface *src, SDL_Rect *srcrect,
        .  		   SDL_Surface *dst, SDL_Rect *dstrect)
        .  {
        .          SDL_Rect fulldst;
        .  	int srcx, srcy, w, h;
        .  
-- line 449 ----------------------------------------
-- line 546 ----------------------------------------
        .  	SDL_SetError("4-bpp rect fill not yet implemented");
        .  	return -1;
        .  }
        .  
        .  /* 
        .   * This function performs a fast fill of the given rectangle with 'color'
        .   */
        .  int SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color)
        9  {
        2  	SDL_VideoDevice *video = current_video;
        .  	SDL_VideoDevice *this  = current_video;
        .  	int x, y;
        .  	Uint8 *row;
        .  
        .  	/* This function doesn't work on surfaces < 8 bpp */
        4  	if ( dst->format->BitsPerPixel < 8 ) {
        .  		switch(dst->format->BitsPerPixel) {
        .  		    case 1:
        .  			return SDL_FillRect1(dst, dstrect, color);
        .  			break;
        .  		    case 4:
        .  			return SDL_FillRect4(dst, dstrect, color);
        .  			break;
        .  		    default:
        .  			SDL_SetError("Fill rect on unsupported surface format");
        .  			return(-1);
        .  			break;
        .  		}
        .  	}
        .  
        .  	/* If 'dstrect' == NULL, then fill the whole surface */
        2  	if ( dstrect ) {
        .  		/* Perform clipping */
        .  		if ( !SDL_IntersectRect(dstrect, &dst->clip_rect, dstrect) ) {
        .  			return(0);
        .  		}
        .  	} else {
        2  		dstrect = &dst->clip_rect;
        .  	}
        .  
        .  	/* Check for hardware acceleration */
        2  	if ( ((dst->flags & SDL_HWSURFACE) == SDL_HWSURFACE) &&
        .  					video->info.blit_fill ) {
        .  		SDL_Rect hw_rect;
        .  		if ( dst == SDL_VideoSurface ) {
        .  			hw_rect = *dstrect;
        .  			hw_rect.x += current_video->offset_x;
        .  			hw_rect.y += current_video->offset_y;
        .  			dstrect = &hw_rect;
        .  		}
        .  		return(video->FillHWRect(this, dst, dstrect, color));
        .  	}
        .  
        .  	/* Perform software fill */
        5  	if ( SDL_LockSurface(dst) != 0 ) {
       18  => /usr/src/debug/SDL-1.2.14/src/video/SDL_surface.c:SDL_LockSurface (1x)
      653  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
        1  		return(-1);
        .  	}
        8  	row = (Uint8 *)dst->pixels+dstrect->y*dst->pitch+
        5  			dstrect->x*dst->format->BytesPerPixel;
        4  	if ( dst->format->palette || (color == 0) ) {
        2  		x = dstrect->w*dst->format->BytesPerPixel;
        8  		if ( !color && !((uintptr_t)row&3) && !(x&3) && !(dst->pitch&3) ) {
        4  			int n = x >> 2;
    1,444  			for ( y=dstrect->h; y; --y ) {
2,310,482  				SDL_memset4(row, 0, n);
      720  				row += dst->pitch;
        .  			}
        .  		} else {
        .  #ifdef __powerpc__
        .  			/*
        .  			 * SDL_memset() on PPC (both glibc and codewarrior) uses
        .  			 * the dcbz (Data Cache Block Zero) instruction, which
        .  			 * causes an alignment exception if the destination is
        .  			 * uncachable, so only use it on software surfaces
-- line 619 ----------------------------------------
-- line 719 ----------------------------------------
        .  		    case 4:
        .  			for(y = dstrect->h; y; --y) {
        .  				SDL_memset4(row, color, dstrect->w);
        .  				row += dst->pitch;
        .  			}
        .  			break;
        .  		}
        .  	}
        2  	SDL_UnlockSurface(dst);
       15  => /usr/src/debug/SDL-1.2.14/src/video/SDL_surface.c:SDL_UnlockSurface (1x)
      679  => /usr/src/debug////////glibc-2.14-394-g8f3b1ff/elf/../sysdeps/x86_64/dl-trampoline.S:_dl_runtime_resolve (1x)
        .  
        .  	/* We're done! */
        2  	return(0);
        7  }
        .  
        .  /*
        .   * Lock a surface to directly access the pixels
        .   */
        .  int SDL_LockSurface (SDL_Surface *surface)
        4  {
        6  	if ( ! surface->locked ) {
        .  		/* Perform the lock */
        6  		if ( surface->flags & (SDL_HWSURFACE|SDL_ASYNCBLIT) ) {
        .  			SDL_VideoDevice *video = current_video;
        .  			SDL_VideoDevice *this  = current_video;
        .  			if ( video->LockHWSurface(this, surface) < 0 ) {
        .  				return(-1);
        .  			}
        .  		}
        4  		if ( surface->flags & SDL_RLEACCEL ) {
        .  			SDL_UnRLESurface(surface, 1);
        .  			surface->flags |= SDL_RLEACCEL;	/* save accel'd state */
        .  		}
        .  		/* This needs to be done here in case pixels changes value */
        6  		surface->pixels = (Uint8 *)surface->pixels + surface->offset;
        .  	}
        .  
        .  	/* Increment the surface lock count, for recursive locks */
        4  	++surface->locked;
        .  
        .  	/* Ready to go.. */
        2  	return(0);
        4  }
        .  /*
        .   * Unlock a previously locked surface
        .   */
        .  void SDL_UnlockSurface (SDL_Surface *surface)
        .  {
        .  	/* Only perform an unlock if we are locked */
       14  	if ( ! surface->locked || (--surface->locked > 0) ) {
        .  		return;
        .  	}
        .  
        .  	/* Perform the unlock */
        4  	surface->pixels = (Uint8 *)surface->pixels - surface->offset;
        .  
        .  	/* Unlock hardware or accelerated surfaces */
        6  	if ( surface->flags & (SDL_HWSURFACE|SDL_ASYNCBLIT) ) {
        .  		SDL_VideoDevice *video = current_video;
        .  		SDL_VideoDevice *this  = current_video;
        .  		video->UnlockHWSurface(this, surface);
        .  	} else {
        .  		/* Update RLE encoded surface with new data */
        6  		if ( (surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL ) {
        .  		        surface->flags &= ~SDL_RLEACCEL; /* stop lying */
        .  			SDL_RLESurface(surface);
        .  		}
        .  	}
        .  }
        .  
        .  /* 
        .   * Convert a surface into the specified pixel format.
-- line 789 ----------------------------------------
-- line 896 ----------------------------------------
        .  	/* We're ready to go! */
        .  	return(convert);
        .  }
        .  
        .  /*
        .   * Free a surface created by the above function.
        .   */
        .  void SDL_FreeSurface (SDL_Surface *surface)
       12  {
        .  	/* Free anything that's not NULL, and not the screen surface */
       10  	if ((surface == NULL) ||
        8  	    (current_video &&
        4  	    ((surface == SDL_ShadowSurface)||(surface == SDL_VideoSurface)))) {
        .  		return;
        .  	}
       10  	if ( --surface->refcount > 0 ) {
        .  		return;
        .  	}
        6  	while ( surface->locked > 0 ) {
        .  		SDL_UnlockSurface(surface);
        .  	}
        6  	if ( (surface->flags & SDL_RLEACCEL) == SDL_RLEACCEL ) {
        .  	        SDL_UnRLESurface(surface, 0);
        .  	}
        6  	if ( surface->format ) {
        2  		SDL_FreeFormat(surface->format);
      183  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_FreeFormat (2x)
        2  		surface->format = NULL;
        .  	}
        6  	if ( surface->map != NULL ) {
        2  		SDL_FreeBlitMap(surface->map);
      372  => /usr/src/debug/SDL-1.2.14/src/video/SDL_pixels.c:SDL_FreeBlitMap (2x)
        2  		surface->map = NULL;
        .  	}
        4  	if ( surface->hwdata ) {
        .  		SDL_VideoDevice *video = current_video;
        .  		SDL_VideoDevice *this  = current_video;
        .  		video->FreeHWSurface(this, surface);
        .  	}
        8  	if ( surface->pixels &&
        1  	     ((surface->flags & SDL_PREALLOC) != SDL_PREALLOC) ) {
        3  		SDL_free(surface->pixels);
       53  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:free (1x)
        .  	}
        4  	SDL_free(surface);
      163  => /usr/src/debug/glibc-2.14-394-g8f3b1ff/malloc/malloc.c:free (2x)
        .  #ifdef CHECK_LEAKS
        .  	--surfaces_allocated;
        .  #endif
       10  }

--------------------------------------------------------------------------------
Ir 
--------------------------------------------------------------------------------
98  percentage of events annotated

